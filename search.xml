<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[antd的下拉框批量导出]]></title>
    <url>%2F2022%2F06%2F05%2Fantd%E7%9A%84%E6%89%B9%E9%87%8F%E5%AF%BC%E5%87%BA%2F</url>
    <content type="text"><![CDATA[工作中需要批量的导出多种情况的要求，于是这里做个笔记，这里设计到了antd的Menu, Dropdown组件的使用： 首先贴一段代码 1234567891011121314// 父组件的按钮// 这里的selectedRow是选中的列表勾选项，这里弄了插槽因为可能不是按钮&lt;ProTable className="txtLibBoxTable" 。。。 actionRef=&#123;actionRef&#125; toolBarRender=&#123;(action, &#123; selectedRows &#125;) =&gt; [&lt;BatchExport selectedRows=&#123;selectedRows&#125;&gt; &lt;Button className='btn4' key="batchExportDoc" onClick=&#123;(e) =&gt; e.preventDefault()&#125; &gt;&lt;img src=&#123;manyoutPic&#125; width=&#123;38&#125; height=&#123;38&#125; alt="" /&gt;批量导出&lt;/Button&gt; &lt;/BatchExport&gt; ]&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292import React, &#123; useState, useEffect, useCallback &#125; from 'react';import &#123; Checkbox, Radio, Menu, Dropdown, Button, message, Modal &#125; from 'antd';import &#123; expordWord, expordWord2 &#125; from '@/pages/DataBases/search/Server';import &#123; exportDocListDirectoryToWord,&#125; from '../../../../../setting/topicManage/server';import &#123; downloadImage &#125; from '../../../../../setting/dataManage/server';import &#123; closePic,&#125; from '@/pages/DataBases/setting/picutils'import Styles from './index.less'const RadioGroup = Radio.Group;const CheckboxGroup = Checkbox.Group;const plainOptions = [ &#123; label: '日期', value: '日期' &#125;, &#123; label: '版名', value: '版名' &#125;, &#123; label: '标题', value: '标题' &#125;, &#123; label: '下标题', value: '标下题' &#125;, &#123; label: '上标题', value: '标上题' &#125;, &#123; label: '版次', value: '版次' &#125;, &#123; label: '作者', value: '作者' &#125;, &#123; label: '库名', value: '库名' &#125;, &#123; label: '来源', value: '来源' &#125;, &#123; label: '原文链接', value: '原文链接' &#125;, &#123; label: '正文', value: '正文' &#125;, &#123; label: '图片', value: '图片' &#125;,];// radio的样式const radioStyle = &#123; display: 'block', height: '30px', lineHeight: '30px',&#125;;interface batchExportProp &#123; selectedRows: Array&lt;any&gt; | undefined, children: any&#125;// 批量导出的四种情况的组件const batchExport = (props: batchExportProp) =&gt; &#123; const &#123; selectedRows, children &#125; = props const [wordDownloadModalVisible, setWordDownloadModalVisible] = useState(false); const [definedDownloadVisible, setdefinedDownloadVisible] = useState(false); const [wordDownloadType, setWordDownloadType] = useState(null); const [indeterminate, setIndeterminate] = useState(true); const [checkAll, setCheckAll] = useState(false); const [checkedList, setCheckedList] = useState([]); // 选中的行数据 const [checkItemList, setCheckItemList] = useState([]) // 下载功能选择 const MenuonClick = (&#123; key &#125;): any =&gt; &#123; // 如果用户没选择列表数据直接报警告！！ if (checkItemList.length === 0) return message.warning('请选择需要下载的内容', 5); if (key === '3' || key === '7') &#123; if (key === '7') &#123; // word目录 exportDocListDirectoryToWord(checkItemList) .then((res) =&gt; &#123; let url = window.URL.createObjectURL(res); let a = document.createElement('a'); document.body.appendChild(a); let fileName = Date.now() + '.doc'; a.href = url; a.download = fileName; a.click(); window.URL.revokeObjectURL(url); document.body.removeChild(a); &#125;) .catch(() =&gt; &#123; message.error('下载失败，请检查网络配置', 5); &#125;); &#125; else if (key === '3') &#123; downloadImage(checkItemList) .then((res) =&gt; &#123; // 构造下载zip的文件 let url = window.URL.createObjectURL(res); let a = document.createElement('a'); document.body.appendChild(a); let fileName = new Date().getTime() + '.zip'; a.href = url; a.download = fileName; a.click(); window.URL.revokeObjectURL(url); document.body.removeChild(a); &#125;) .catch(() =&gt; &#123; message.error('下载失败，请检查网络配置', 5); &#125;); &#125; &#125; &#125;; // 下载word弹框 const downloadWord = () =&gt; &#123; return checkItemList.length !== 0 ? setWordDownloadModalVisible(true) : message.warning('请选择需要下载的内容', 5); &#125;; // 自定义下载word弹框 const definedDownloadWord = () =&gt; &#123; return checkItemList.length !== 0 ? setdefinedDownloadVisible(true) : message.warning('请选择需要下载的内容', 5); &#125;; // word下载确认 const handleModalOk = () =&gt; &#123; setWordDownloadModalVisible(false); // 参数 let params = &#123; judge: wordDownloadType, fields: '', isAll: true, &#125;; // 多个 txt与文件 zip expordWord2(checkItemList, params) .then((res) =&gt; &#123; let url = window.URL.createObjectURL(res); let a = document.createElement('a'); document.body.appendChild(a); let fileName = Date.now() + '.doc'; a.href = url; a.download = fileName; a.click(); window.URL.revokeObjectURL(url); document.body.removeChild(a); &#125;) .catch(() =&gt; &#123; message.error('下载失败，请检查网络配置', 5); &#125;); &#125;; // 自定义 word下载确认 const handleModalOk2 = () =&gt; &#123; setdefinedDownloadVisible(false); // 参数 let params = &#123; judge: true, fields: checkedList, isAll: false, &#125;; expordWord(checkItemList, params) .then((res) =&gt; &#123; // 构造下载doc的文件 let url = window.URL.createObjectURL(res); let a = document.createElement('a'); document.body.appendChild(a); let fileName = Date.now() + '.doc'; a.href = url; a.download = fileName; a.click(); window.URL.revokeObjectURL(url); document.body.removeChild(a); &#125;) .catch(() =&gt; &#123; message.error('下载失败，请检查网络配置', 5); &#125;); &#125;; // 下载下拉菜单html // 【菜单使用 Menu，还包括菜单项 Menu.Item，分割线 Menu.Divider】 // 【注意： Menu.Item 必须设置唯一的 key 属性。】 const menu = ( &lt;Menu onClick=&#123;MenuonClick&#125;&gt; &#123;/* 这个点击函数会穿个Key就是下面的key,可以根据判断点击了哪个 */&#125; &lt;Menu.Item key="3"&gt;下载(zip)&lt;/Menu.Item&gt; &lt;&gt; &lt;Menu.Divider /&gt; &lt;Menu.Item key="6" onClick=&#123;() =&gt; downloadWord()&#125;&gt; 下载(word) &lt;/Menu.Item&gt; &lt;Menu.Divider /&gt; &lt;Menu.Item key="5" onClick=&#123;() =&gt; definedDownloadWord()&#125;&gt; 自定义下载(word) &lt;/Menu.Item&gt; &lt;Menu.Divider /&gt; &lt;Menu.Item key="7"&gt;下载目录(word)&lt;/Menu.Item&gt; &lt;/&gt; &lt;/Menu&gt; ); // 取消 const handleCancel = useCallback(() =&gt; &#123; setWordDownloadModalVisible(false); &#125;, []); // 自定义取消 const handleCancel2 = useCallback(() =&gt; &#123; setdefinedDownloadVisible(false); &#125;, []); // 选择word下载类型 const handlerSelectType = (e: any) =&gt; &#123; setWordDownloadType(e.target.value); &#125;; // 自定义Word下载弹窗的全选事件 const onCheckAllChange = (e: any) =&gt; &#123; const allCheck = [ '日期', '版名', '标上题', '标题', '标下题', '版次', '作者', '库名', '来源', '原文链接', '正文', '图片', ]; setCheckedList(e.target.checked ? allCheck : []); setIndeterminate(false), setCheckAll(e.target.checked); &#125;; // 自定义Word下载弹窗的CheckOnChange事件 const handlerCheckOnChange = (checkedList: any) =&gt; &#123; setCheckedList(checkedList); setIndeterminate(!!checkedList.length &amp;&amp; checkedList.length &lt; plainOptions.length), setCheckAll(checkedList.length === plainOptions.length); &#125;; // 新的批量导出最上面的按钮处理事件函数 const handleBatchExportNew = useCallback((e) =&gt; &#123; e.preventDefault(); &#125;, []); useEffect(() =&gt; &#123; // 传入的数组变了要保存 setCheckItemList(selectedRows) &#125;, [selectedRows]) return ( &lt;&gt; &lt;Dropdown overlayClassName=&#123;'txtLibDropdown'&#125; overlay=&#123;menu&#125; trigger=&#123;['hover']&#125; // 触发下拉的行为 getPopupContainer=&#123;(triggerNode) =&gt; triggerNode.parentNode&#125; // 这个函数解决下拉框错位的问题：https://blog.csdn.net/zeng__yi/article/details/83507429 &gt; &#123;children&#125; &#123;/* &lt;Button className='btn4' key="batchExportDoc" onClick=&#123;(e) =&gt; handleBatchExportNew(e)&#125; &gt;&lt;img src=&#123;manyoutPic&#125; width=&#123;38&#125; height=&#123;38&#125; alt="" /&gt;批量导出&lt;/Button&gt; */&#125; &lt;/Dropdown&gt; &#123;/* 下载word弹窗 */&#125; &lt;Modal closeIcon=&#123;&lt;img src=&#123;closePic&#125; width=&#123;29&#125; height=&#123;29&#125; /&gt;&#125; className=&#123;Styles.batchExportBox&#125; title="Word下载" visible=&#123;wordDownloadModalVisible&#125; onOk=&#123;handleModalOk&#125; onCancel=&#123;handleCancel&#125; &gt; &lt;RadioGroup onChange=&#123;handlerSelectType&#125; value=&#123;wordDownloadType&#125;&gt; &lt;Radio style=&#123;radioStyle&#125; value=&#123;true&#125;&gt; 带原文链接下载 &lt;/Radio&gt; &lt;Radio style=&#123;radioStyle&#125; value=&#123;false&#125;&gt; 不带原文链接下载 &lt;/Radio&gt; &lt;/RadioGroup&gt; &lt;/Modal&gt; &#123;/* 自定义Word下载弹窗 */&#125; &lt;Modal closeIcon=&#123;&lt;img src=&#123;closePic&#125; width=&#123;29&#125; height=&#123;29&#125; /&gt;&#125; className=&#123;Styles.batchExportBox&#125; title="自定义Word下载" visible=&#123;definedDownloadVisible&#125; onOk=&#123;handleModalOk2&#125; onCancel=&#123;handleCancel2&#125; &gt; &lt;div style=&#123;&#123; borderBottom: '1px solid #E9E9E9' &#125;&#125;&gt; &lt;Checkbox indeterminate=&#123;indeterminate&#125; onChange=&#123;onCheckAllChange&#125; checked=&#123;checkAll&#125;&gt; 全选 &lt;/Checkbox&gt; &lt;/div&gt; &lt;br /&gt; &lt;CheckboxGroup options=&#123;plainOptions&#125; value=&#123;checkedList&#125; onChange=&#123;handlerCheckOnChange&#125; /&gt; &lt;/Modal&gt; &lt;/&gt; )&#125;export default React.memo(batchExport) 参考资料： https://ant.design/components/dropdown-cn/]]></content>
      <categories>
        <category>antd</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[antd的图片裁剪]]></title>
    <url>%2F2022%2F06%2F02%2Fantd%E7%9A%84%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA%2F</url>
    <content type="text"><![CDATA[工作中需要对图片进行图片裁剪的要求，于是这里做个笔记： 首先贴一段代码，需要安装【react-cropper】这个插件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236import &apos;./index.less&apos;;import &#123; Tooltip, Button, Modal, message &#125; from &apos;antd&apos;;import React, &#123; useRef, useState, useEffect &#125; from &apos;react&apos;;import &#123; closePic &#125; from &apos;@/pages/DataBases/setting/picutils&apos;;import &#123; useToggleVal &#125; from &apos;@/utils/hook/common&apos;;import Cropper from &apos;react-cropper&apos; // 引入Cropperimport &apos;cropperjs/dist/cropper.css&apos; // 引入Cropper对应的css//阿里巴巴矢量图标库引入import &#123; createFromIconfontCN &#125; from &apos;@ant-design/icons&apos;;import &#123; uploadImage &#125; from &apos;../../../server&apos;;import &#123; editDocById &#125; from &apos;@/pages/DataBases/setting/topicManageNew/server&apos;;const IconFont = createFromIconfontCN(&#123; scriptUrl: &apos;//at.alicdn.com/t/c/font_3573782_amwh7c9a9wd.js&apos;,&#125;);export function useToggleVal(initial?: number) &#123; const [_flag, _setFlag] = useState(initial) const setFlag = useCallback(() =&gt; &#123; _setFlag(prev =&gt; &#123; return prev === 1 ? -1 : 1 &#125;) &#125;, []) return [_flag, setFlag]&#125;const renderButStr = &#123; &apos;icon-yidong&apos;: &apos;移动&apos;, &apos;icon-caijian&apos;: &apos;裁剪&apos;, &apos;icon-left-rotate&apos;: &apos;左旋转&apos;, &apos;icon-right-rotate&apos;: &apos;右旋转&apos;, &apos;icon-scaleX&apos;: &apos;水平翻转&apos;, &apos;icon-scaleY&apos;: &apos;上下翻转&apos;, &apos;icon-clear&apos;: &apos;清空&apos;, &apos;icon-reset&apos;: &apos;复原&apos;,&#125;const CropperEditPic = (props) =&gt; &#123; const &#123; cropperPic, cropperVisible, setCropperVisible, curRow, updateItem &#125; = props; const [imgUrl, setImgUrl] = useState&lt;string&gt;(&apos;&apos;); const [_flag, setFlag] = useToggleVal(-1) const [_flag2, setFlag2] = useToggleVal(-1) const cropperRef = useRef(null); const inputVal = useRef(null); // 渲染按钮 const renderButton = (onClick1: Function, onClick2: Function, name1: string, name2: string, tipname1: string, tipname2: string) =&gt; &#123; return ( &lt;div className=&apos;buttonGroup&apos;&gt; &lt;Tooltip title=&#123;renderButStr[tipname1]&#125;&gt; &lt;Button onClick=&#123;onClick1&#125; &gt;&lt;IconFont type=&#123;name1&#125; /&gt;&lt;/Button&gt; &lt;/Tooltip&gt; &lt;Tooltip title=&#123;renderButStr[tipname2]&#125;&gt; &lt;Button className=&#123;name1 === name2 ? &apos;rotation_inverted&apos; : &apos;&apos;&#125; onClick=&#123;onClick2&#125; &gt;&lt;IconFont type=&#123;name2&#125; /&gt;&lt;/Button&gt; &lt;/Tooltip&gt; &lt;/div&gt; ) &#125; const handleOk = () =&gt; &#123; setCropperVisible(); &#125;; const handleCancel = () =&gt; &#123; setCropperVisible(); &#125;; // 选择文件的打开事件 const handleChangeFile = (e) =&gt; &#123; console.log(e) const file = e.target.files[0]; const blobData = window.URL.createObjectURL(file); // 构造临时的url地址 setImgUrl(blobData); &#125;; const moveClick = () =&gt; &#123; cropperRef.current.cropper.setDragMode(&apos;move&apos;); &#125; const cropClick = () =&gt; &#123; cropperRef.current.cropper.setDragMode(&apos;crop&apos;); &#125; const rotateClick = () =&gt; &#123; cropperRef.current.cropper.rotate(45); &#125; const rotateInvertedClick = () =&gt; &#123; cropperRef.current.cropper.rotate(-45); &#125; const transverseClick = () =&gt; &#123; setFlag(); cropperRef.current.cropper.scaleX(_flag); &#125; const verticalClick = () =&gt; &#123; setFlag2(); cropperRef.current.cropper.scaleY(_flag2); &#125; const largeClick = () =&gt; &#123; cropperRef.current.cropper.zoom(0.1); &#125; const smallClick = () =&gt; &#123; cropperRef.current.cropper.zoom(-0.1); &#125; const resetClick = () =&gt; &#123; cropperRef.current.cropper.reset(); &#125; const deleteClick = () =&gt; &#123; cropperRef.current.cropper.clear() &#125; /* Uncaught DOMException: Failed to execute &apos;toDataURL&apos; on &apos;HTMLCanvasElement&apos;: Tainted canvases may not be exported. canvas无法执行toDataURL方法：污染的画布无法输出，请原谅我的灵魂翻译。经google 发现原来是受限于 CORS 策略，会存在跨域问题，虽然可以使用图像（比如append到页面上）但是绘制到画布上会污染画布，一旦一个画布被污染, 就无法提取画布的数据，比如无法使用使用画布toBlob(), toDataURL(), 或getImageData()方法;当使用这些方法的时候 会抛出一个安全错误 */ const btnSubmit = () =&gt; &#123; const params = &#123; width: 160, height: 90, minWidth: 256, minHeight: 256, maxWidth: 4096, maxHeight: 4096, fillColor: &apos;#fff&apos;, imageSmoothingEnabled: false, imageSmoothingQuality: &apos;high&apos;, // 设置图像平滑的质量，设置为“低”（默认）、“中等”或“高”之一。 &#125; cropperRef.current.cropper.getCroppedCanvas(params).toBlob(blob =&gt; &#123; return cropperPic(blob, updateItem) &#125;) &#125;; // 将网络图片转换成base64格式 const transBase64FromImage = (image) =&gt; &#123; let canvas = document.createElement(&quot;canvas&quot;); canvas.width = image.width; canvas.height = image.height; let ctx = canvas.getContext(&quot;2d&quot;); ctx &amp;&amp; ctx.drawImage(image, 0, 0, image.width, image.height); // 可选其他值 image/jpeg return canvas.toDataURL(&quot;image/jpeg&quot;); &#125; useEffect(() =&gt; &#123; // 设置打开窗口显示的裁剪图片 if (curRow !== &apos;&apos;) &#123; setImgUrl(curRow); &#125; &#125;, [curRow]) return ( &lt;&gt; &lt;Modal maskClosable=&#123;false&#125; className=&apos;CropperEditPicModal&apos; style=&#123;&#123; minHeight: &apos;50vh&apos; &#125;&#125; width=&#123;&apos;50vw&apos;&#125; closeIcon=&#123;&lt;img src=&#123;closePic&#125; width=&#123;29&#125; height=&#123;29&#125; /&gt;&#125; title=&#123;&apos;图片剪裁&apos;&#125; visible=&#123;cropperVisible&#125; onOk=&#123;handleOk&#125; footer=&#123;null&#125; onCancel=&#123;handleCancel&#125; &gt; &lt;div className=&quot;s-upload-main&quot;&gt; &lt;div className=&quot;top-box&quot;&gt; &lt;div className=&quot;btn file-box&quot;&gt; &lt;span&gt;选择文件...&lt;/span&gt;&lt;input ref=&#123;inputVal&#125; id=&quot;file&quot; type=&quot;file&quot; name=&quot;singlePhoto&quot; accept=&quot;image/*&quot; className=&quot;btn&quot; onChange=&#123;handleChangeFile&#125; /&gt; &lt;/div&gt; &#123;renderButton(moveClick, cropClick, &apos;icon-yidong&apos;, &apos;icon-caijian&apos;, &apos;icon-yidong&apos;, &apos;icon-caijian&apos;)&#125; &#123;renderButton(rotateClick, rotateInvertedClick, &apos;icon-icon_rotate&apos;, &apos;icon-icon_rotate&apos;, &apos;icon-left-rotate&apos;, &apos;icon-right-rotate&apos;)&#125; &#123;renderButton(transverseClick, verticalClick, &apos;icon-link-arrow-h-full&apos;, &apos;icon-link-arrow-v-full&apos;, &apos;icon-scaleX&apos;, &apos;icon-scaleY&apos;)&#125; &#123;renderButton(deleteClick, resetClick, &apos;icon-quxiao&apos;, &apos;icon-icon-refresh&apos;, &apos;icon-clear&apos;, &apos;icon-reset&apos;)&#125; &lt;Button className=&apos;preservation&apos; onClick=&#123;btnSubmit&#125;&gt;保存&lt;/Button&gt; &lt;/div&gt; &lt;div className=&quot;s-upload-content&quot;&gt; &lt;div className=&quot;left-box&quot;&gt; &lt;Cropper style=&#123;&#123; height: 400 &#125;&#125; // cropper对象注意设置checkCrossOrigin和checkOrientation两个属性，就能跨域访问了 // checkOrientation=&#123;false&#125; // checkCrossOrigin=&#123;false&#125; src=&#123;imgUrl&#125; // 元素或元素数组或节点列表对象或 Document.querySelector 的所有有效选择器 preview=&#123;&apos;.previewBox&apos;&#125; ref=&#123;cropperRef&#125; initialAspectRatio=&#123;1&#125; //定义裁剪框的初始宽高比 viewMode=&#123;0&#125; //裁剪框不能超过画布大小 guides=&#123;true&#125; //网格线 minCropBoxHeight=&#123;10&#125; //最小高度 minCropBoxWidth=&#123;10&#125; background=&#123;false&#125; movable=&#123;true&#125; cropBoxMovable=&#123;true&#125; //裁剪框是否移动 cropBoxResizable=&#123;true&#125; //裁剪框大小是否变化 scalable=&#123;true&#125; //是否可以放大 rotatable=&#123;true&#125; //是否可以旋转 dragMode=&#123;&apos;move&apos;&#125; //单击设置为移动图片 //这个比较重要，单击时，设置裁剪框不可变化 toggleDragModeOnDblclick=&#123;false&#125; //这个也比较重要，对于有方向值的图片是否根据方向值旋转 checkOrientation=&#123;false&#125; /&gt; &lt;/div&gt; &lt;div className=&quot;right-box&quot;&gt; &#123;/* preview=&#123;&apos;.previewBox&apos;&#125;设置右侧预览的图片，对应的是dom元素 */&#125; &lt;div className=&quot;previewBox&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/Modal&gt; &lt;/&gt; );&#125;;export default React.memo(CropperEditPic); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204/* 图片裁剪的样式文件 */.CropperEditPicModal &#123; .ant-modal-body &#123; padding: 0 !important; padding-top: 23px !important; &#125; .ant-modal-header &#123; border-radius: 10px 10px 0 0 !important; background-color: #2a82e4 !important; .ant-modal-title &#123; color: #fff !important; font-weight: bold; &#125; &#125; .ant-modal-content &#123; border-radius: 10px 10px 0 0 !important; &#125; .CropperBox &#123; height: 700px; .CropperBoxHeader &#123; background-color: #fff; height: 60px; text-align: center; &#125; .CropperBoxContent &#123; justify-content: center; align-items: center; display: flex; height: 92%; background-color: #e9f2fc; .xi-cropper-wrap &#123; width: 660px !important; height: 400px !important; &#125; .xi-cropper-upload &#123; width: 660px !important; height: 400px !important; &#125; input &#123; width: 660px !important; height: 400px !important; &#125; .xi-cropper-file &#123; width: 660px !important; height: 400px !important; &#125; &#125; .chooseBtn &#123; margin-bottom: 30px; background-color: #5ebc5e; width: 5vw; height: 42px; font-size: 17px; border: 1px solid #5ebc5e; border-radius: 6px; color: #fff; cursor: pointer; &#125; &#125; /* cropper主体 */ .s-upload-main &#123; position: relative; .top-box &#123; overflow: hidden; margin-bottom: 18px; display: flex; justify-content: center; align-items: center; .file-box &#123; position: relative; overflow: hidden; background: #eca054; border-radius: 5px; span &#123; color: #fff; padding: 0 10px; display: block; height: 40px; line-height: 40px; font-size: 18px; &#125; .btn &#123; position: absolute; left: 0; right: 0; bottom: 0; top: 0; opacity: 0; width: 100%; height: 100%; &#125; &#125; .buttonGroup &#123; margin: 0 0 0 10px; border-radius: 5px; overflow: hidden; display: flex; .ant-btn&#123; border-radius: 0; border: none !important; height: 40px; padding: 0 15px; background: #2a82e4; display: flex; align-items: center; &amp;.rotation_inverted&#123; svg&#123; transform: scaleX(-1); &#125; &#125; &amp;:hover&#123; background: #2a82e4; &#125; span&#123; font-size: 18px; color: #fff; &#125; &#125; &#125; .preservation &#123; height: 40px; line-height: 40px; padding: 0 10px; width: auto; border: none; background: #28A745; border-radius: 5px; margin: 0 0 0 10px; color: #fff; font-size: 18px; &#125; &#125; .s-upload-content &#123; height: 500px; display: flex; justify-content: space-between; overflow: hidden; background: rgba(233, 242, 252, 1); padding: 30px; .left-box &#123; float: left; width: 66%; height: 520px; .image &#123; display: block; width: 100%; max-width: 100%; &#125; &#125; .right-box &#123; float: right; height: 200px; background: #ececec; .previewBox &#123; width: 250px; height: 250px; overflow: hidden; /* 这个属性可以得到想要的效果 */ &#125; &#125; &#125; &#125; :gabel &#123; .xi-cropper-modal &#123; position: relative; .xi-cropper-modalMask &#123; display: none; &#125; &#125; &#125; .xi-cropper-modal .cropper-modal-content &#123; // top: 360px !important; &#125; .xi-cropper-modal .cropper-modal-content .cropper-modal-header &#123; font-size: 16px !important; &#125;&#125; 这个插件的几个重要属性：&lt;Cropper src={imgUrl} // 元素或元素数组或节点列表对象或 Document.querySelector 的所有有效选择器 preview={‘.previewBox’} /&gt; 这个【src是展示的图片地址】，如果是跨域访问的图片地址，他是展示不出来的，就算设置了跨域访问，保存也是保存不了的，他会提示有污染的画布。注意这点！！！！ 这个【preview是预览的dom元素】 详细的属性介绍可以参考插件的网址。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 const blobToFile = (blob, fileName) =&gt; &#123; return new window.File([blob], fileName, &#123; type: blob.type &#125;) &#125;// 父组件裁剪图片的方法 const cropperPic = (blob, updateItem) =&gt; &#123; const formData = new FormData(); // Pass the image file name as the third parameter if necessary. const newfile = blobToFile(blob, &apos;pic.png&apos;) // 要把blob转成file对象，同时要给文件的后缀名，接口要求！！ //向 FormData 中添加新的属性值，FormData 对应的属性值存在也不会覆盖原值，而是新增一个值，如果属性不存在则新增一项属性值。 formData.append(&apos;file&apos;, newfile); uploadImage(formData).then(res =&gt; &#123; if (res.code === 200) &#123; const updateParams = &#123; ...updateItem, fmLink: res.data.fmLink, fsLink: res.data.fsLink, f_Link: res.data.f_Link, &#125; editDocById([updateParams]).then((res) =&gt; &#123; if (res.code !== 200) return message.error(&apos;上传图片失败&apos;); message.success(&apos;上传图片成功&apos;); setCropperVisible(false); handleSearch(); &#125;).catch(err =&gt; &#123; return message.error(&apos;上传图片失败&apos;); &#125;); &#125; else &#123; return message.erlibraryListror(res.message || &apos;上传图片失败&apos;, 10); &#125; &#125;).catch(err =&gt; &#123; return message.error(&apos;上传图片失败&apos;); &#125;); &#125; .....return ( &#123; cropperVisible &amp;&amp; &lt;CropperEditPic cropperPic=&#123;cropperPic&#125; setCropperVisible=&#123;setCropperVisible&#125; cropperVisible=&#123;cropperVisible&#125; curRow=&#123;cropperCurRowUrl&#125; updateItem=&#123;cropperItem&#125; /&gt; &#125; 参考资料： https://fengyuanchen.github.io/cropperjs/https://github.com/fengyuanchen/cropperjs/blob/main/README.md]]></content>
      <categories>
        <category>antd</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[antd的表单动态增加]]></title>
    <url>%2F2022%2F06%2F01%2Fantd%E7%9A%84%E8%A1%A8%E5%8D%95%E5%8A%A8%E6%80%81%E5%A2%9E%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[该文介绍我在项目中遇到的动态增加表单问题 首先贴一段代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268import &#123; Card &#125; from &apos;antd&apos;;import React, &#123; useState, useCallback &#125; from &apos;react&apos;import &#123; MinusCircleOutlined, PlusOutlined &#125; from &apos;@ant-design/icons&apos;;import &#123; Button, Form, Input, Select, Space &#125; from &apos;antd&apos;;const &#123; Option &#125; = Select;const areas = [ &#123; label: &apos;Beijing&apos;, value: &apos;Beijing&apos; &#125;, &#123; label: &apos;Shanghai&apos;, value: &apos;Shanghai&apos; &#125;,];const containers = [ &#123; label: &apos;包含&apos;, value: &apos;Y&apos; &#125;, &#123; label: &apos;不包含&apos;, value: &apos;N&apos; &#125;,];const sights = &#123; Beijing: [&apos;Tiananmen&apos;, &apos;Great Wall&apos;], Shanghai: [&apos;Oriental Pearl&apos;, &apos;The Bund&apos;],&#125;;type sightsKeys = keyof typeof sights;interface yearobj &#123; id: number; zt_year: string;&#125;const addForm = () =&gt; &#123; const [ztlist, setZtlist] = useState&lt;yearobj[]&gt;([]) const [monthList, setMonthList] = useState([]) const [form] = Form.useForm(); const onFinish = (values: any) =&gt; &#123; console.log(&apos;Received values of form:&apos;, values); &#125;; const handleChange = () =&gt; &#123; form.setFieldsValue(&#123; sights: [] &#125;); &#125;; // 展开专题年份的下拉框 const handleOpenSelect = (open) =&gt; &#123; if (open) &#123; const yearsArr = [ &#123; id: 1, zt_year: &apos;2017&apos; &#125;, &#123; id: 2, zt_year: &apos;2018&apos; &#125;, &#123; id: 3, zt_year: &apos;2019&apos; &#125;, &#123; id: 4, zt_year: &apos;2020&apos; &#125; ] setZtlist(yearsArr); &#125; &#125; // 年份字段值发生改变 const handleSelectChange = useCallback( (index) =&gt; &#123; console.log(&apos;选择年份...&apos;) const monthArr = [ &#123; id: 1, month: &apos;一月&apos; &#125;, &#123; id: 2, month: &apos;二月&apos; &#125;, &#123; id: 3, month: &apos;三月&apos; &#125;, &#123; id: 4, month: &apos;四月&apos; &#125; ] setMonthList(monthArr); &#125;, [] ); // 处理点击加号，新增 const handleClickAdd = async (add, fields) =&gt; &#123; console.log(&apos;addd.....&apos;) console.log(form.getFieldsValue()) // console.log(form.getFieldValue(&apos;sights&apos;)); // console.log(form.getFieldValue(&apos;sights&apos;).length); // 这里的下一个元素是undefined，要赋值为最新的 // const oldArr = [...form.getFieldValue(&apos;sights&apos;)]; // console.log(oldArr) // 这是最新添加的表单项的值 // const newsObj = form.getFieldValue(&apos;sights&apos;)[form.getFieldValue(&apos;sights&apos;).length - 1] // console.log(newsObj) // 触发表单校验 const fieldsValue = await form.validateFields(); console.log(fieldsValue); add(&#123; names: &apos;我是默认的名字&apos;, contain: &quot;Y&quot; &#125;, 0) // add: (defaultValue?: StoreValue, insertIndex?: number) =&gt; void; // 源码中：第一个对象是默认值，后面是插入的位置，我这里是0就每次都插在第一个 /* add(&#123; // subjectName: newsObj.subjectName || fieldsValue.sights[0].subjectName, category: newsObj.category || fieldsValue.sights[0].category, subjectYear: newsObj.subjectYear || fieldsValue.sights[0].subjectYear, &#125;); */ &#125; return ( &lt;Form initialValues=&#123;&#123; keywordsOne: &#123; contain: &apos;Y&apos;, keywords: &apos;默认的关键词&apos; &#125; &#125;&#125; form=&#123;form&#125; name=&quot;dynamic_form_nest_item&quot; onFinish=&#123;onFinish&#125; autoComplete=&quot;off&quot;&gt; &lt;Form.Item label=&#123;&apos;订阅夹名称&apos;&#125; name=&quot;subname&quot; rules=&#123;[ &#123; required: true, message: &apos;请输入订阅夹名称!&apos; &#125;, /* &#123; max: 6, message: &apos;订阅夹名称长度不超过6&apos; &#125;, &#123; message: &apos;只能输入中文字符&apos;, pattern: /^[\u4e00-\u9fa5]+$/i, // 限制只能输入中文 &#125;, */ &#123; validator: function (rule, value, callback) &#123; try &#123; if (value &amp;&amp; value.length &gt; 6) &#123; throw new Error(&apos;订阅夹名称长度不超过6&apos;); &#125; // 因为自定义校验规则都会走到这里，我们不输入值的话会进行判断中文字符刚好他也符合 // 就会弹出两个提示，所以这里做个判断直接callback if (!value) &#123; console.log(&apos;进入了&apos;); callback(); &#125; if (!(/^[\u4E00-\u9FA5]+$/.test(value))) &#123; throw new Error(&apos;只能输入中文字符&apos;); &#125; callback(); &#125; catch (err) &#123; callback(err); &#125; &#125; &#125; ]&#125; &gt; &lt;Input style=&#123;&#123; width: &apos;14vw&apos; &#125;&#125; className=&apos;subNameClass&apos; placeholder=&apos;请输入订阅夹名称&apos; /&gt; &lt;/Form.Item&gt; &lt;Form.Item label=&quot;第一行的关键词&quot;&gt; &lt;Input.Group compact&gt; &lt;Form.Item style=&#123;&#123; marginRight: &apos;20px&apos; &#125;&#125; name=&#123;[&apos;keywordsOne&apos;, &apos;contain&apos;]&#125; &gt; &lt;Select placeholder=&quot;请选择&quot;&gt; &lt;Option value=&quot;Y&quot;&gt;包含&lt;/Option&gt; &lt;Option value=&quot;N&quot;&gt;不包含&lt;/Option&gt; &lt;/Select&gt; &lt;/Form.Item&gt; &lt;Form.Item name=&#123;[&apos;keywordsOne&apos;, &apos;keywords&apos;]&#125; noStyle &gt; &lt;Input style=&#123;&#123; width: &apos;14vw&apos; &#125;&#125; placeholder=&quot;请输入关键词&quot; /&gt; &lt;/Form.Item&gt; &lt;/Input.Group&gt; &lt;/Form.Item&gt; &lt;Form.List name=&quot;sights&quot;&gt; &#123;/* Form.List 下的字段需要包裹 Form.List 本身的 nam */&#125; &#123;(fields, &#123; add, remove &#125;) =&gt; ( &lt;&gt; &#123;fields.map((field, index) =&gt; ( &lt;Space key=&#123;field.key&#125; align=&quot;baseline&quot;&gt; &lt;Form.Item &#123;...field&#125; name=&#123;[field.name, &apos;subjectYear&apos;]&#125; label=&quot;专题年份&quot; &gt; &lt;Select placeholder=&quot;请选择年份&quot; onDropdownVisibleChange=&#123;handleOpenSelect&#125; onChange=&#123;() =&gt; handleSelectChange(index)&#125;&gt; &#123;ztlist.map((item) =&gt; &#123; return ( &lt;Option value=&#123;item.zt_year&#125; key=&#123;item.zt_year&#125;&gt; &#123;item.zt_year&#125; &lt;/Option&gt; ); &#125;)&#125; &lt;/Select&gt; &lt;/Form.Item&gt; &lt;Form.Item noStyle shouldUpdate=&#123;(prevValues, curValues) =&gt; prevValues.area !== curValues.area || prevValues.sights !== curValues.sights &#125; &gt; &#123;() =&gt; ( &lt;Form.Item &#123;...field&#125; label=&quot;包含类型&quot; name=&#123;[field.name, &apos;contain&apos;]&#125; rules=&#123;[&#123; required: true, message: &apos;必须选择其中一项&apos; &#125;]&#125; &gt; &#123;/* disabled=&#123;!form.getFieldValue(&apos;area&apos;)&#125; */&#125; &lt;Select style=&#123;&#123; width: &quot;10vw&quot; &#125;&#125;&gt; &#123;(/* sights[form.getFieldValue(&apos;area&apos;) as sightsKeys] */containers || []).map(item =&gt; ( &lt;Option key=&#123;item&#125; value=&#123;item.value&#125;&gt; &#123;item.label&#125; &lt;/Option&gt; ))&#125; &lt;/Select&gt; &lt;/Form.Item&gt; )&#125; &lt;/Form.Item&gt; &lt;Form.Item &#123;...field&#125; label=&quot;月份&quot; name=&#123;[field.name, &apos;month&apos;]&#125; &gt; &lt;Select style=&#123;&#123; width: &apos;5vw&apos; &#125;&#125;&gt; &#123;monthList.map((item) =&gt; &#123; return ( &lt;Option value=&#123;item.month&#125; key=&#123;item.month&#125;&gt; &#123;item.month&#125; &lt;/Option&gt; ); &#125;)&#125; &lt;/Select&gt; &lt;/Form.Item&gt; &lt;Form.Item &#123;...field&#125; label=&quot;关键词&quot; name=&#123;[field.name, &apos;keywords&apos;]&#125; &gt; &lt;Input placeholder=&apos;请输入关键词，多个以逗号分割开~&apos; style=&#123;&#123; width: &quot;15vw&quot; &#125;&#125; /&gt; &lt;/Form.Item&gt; &lt;Form.Item &#123;...field&#125; label=&apos;姓名&apos; name=&#123;[field.name, &apos;names&apos;]&#125; validateTrigger=&#123;[&apos;onChange&apos;, &apos;onBlur&apos;]&#125; rules=&#123;[ &#123; required: true, whitespace: true, message: &quot;Please input passenger&apos;s name or delete this field.&quot;, &#125;, ]&#125; noStyle &gt; &lt;Input placeholder=&quot;passenger name&quot; style=&#123;&#123; width: &apos;15vw&apos; &#125;&#125; /&gt; &lt;/Form.Item&gt; &lt;MinusCircleOutlined onClick=&#123;() =&gt; remove(field.name)&#125; /&gt; &lt;/Space&gt; ))&#125; &lt;Form.Item&gt; &lt;Button style=&#123;&#123; width: &quot;20vw&quot;, backgroundColor: &apos;grey&apos;, color: &apos;#fff&apos; &#125;&#125; type=&quot;dashed&quot; onClick=&#123;() =&gt; handleClickAdd(add, fields)&#125; block icon=&#123;&lt;PlusOutlined /&gt;&#125;&gt; 【添加新的表单项】 &lt;/Button&gt; &lt;/Form.Item&gt; &lt;/&gt; )&#125; &lt;/Form.List&gt; &lt;Form.Item &gt; &lt;Button type=&quot;primary&quot; htmlType=&quot;submit&quot;&gt; Submit &lt;/Button&gt; &lt;/Form.Item&gt; &lt;/Form&gt; );&#125;export default React.memo(addForm) 这里说几个要注意的点：1、form表单如果想要初始化表单值的话有两种方法，【默认值可以用 Form 里的 initialValues 来设置。注意 initialValues 不能被 setState 动态更新，你需要用 setFieldsValue 来更新。】①&lt;Form 1234&gt; initialValues=&#123;&#123;&gt; keywordsOne: &#123; contain: 'Y', keywords: '默认的关键词' &#125;&gt; &#125;&#125;&gt; ②就是使用form.setFieldsValue回显数据动态表单项 123&gt; form.setFieldsValue(&#123;&gt; addformItems: restArr &#125;)&gt; 2、如果对Input进行自定义校验的话有以下需要注意的地方： pattern: /^[\u4e00-\u9fa5]+$/i, 【 限制只能输入中文】但是这样可能会出现必填和中文的提示占两行。注：这时候可以把长度判断和中文判断放到自定义校验里面，因为他先走了必填的校验，然后会接着走到自定义校验，然后这个时候value是没有值的，然后判断到空格也不是中文，所以也会出现必填和中文的提示占两行。这个时候可以判断如果他没值的话就直接callback()就不会走到下一个判断。代码如下： 12345678910111213141516171819202122232425262728293031&gt; rules=&#123;[&gt; &#123; required: true, message: '请输入订阅夹名称!' &#125;,&gt; /* &#123; max: 6, message: '订阅夹名称长度不超过6' &#125;,&gt; &#123;&gt; message: '只能输入中文字符',&gt; pattern: /^[\u4e00-\u9fa5]+$/i,&gt; // 限制只能输入中文&gt; &#125;, */&gt; &#123;&gt; validator: function (rule, value, callback) &#123;&gt; try &#123;&gt; if (value &amp;&amp; value.length &gt; 6) &#123;&gt; throw new Error('订阅夹名称长度不超过6');&gt; &#125;&gt; // **因为自定义校验规则都会走到这里，我们不输入值的话会进行判断中文字符刚好他也符合**&gt; // **就会弹出两个提示，所以这里做个判断直接callback**&gt; if (!value) &#123;&gt; console.log('进入了');&gt; callback();&gt; &#125;&gt; if (!(/^[\u4E00-\u9FA5]+$/.test(value))) &#123;&gt; throw new Error('只能输入中文字符');&gt; &#125;&gt; callback(); // 必须要callback()的&gt; &#125; catch (err) &#123;&gt; callback(err);&gt; &#125;&gt; &#125;&gt; &#125;&gt; ]&#125;&gt; 3、每个form的item的Label对应的是表单项前面的文字会自动为你补上文字加冒号。例如： &lt;Form.Item label=”第一行的关键词”&gt; 4、因为这个代码，我们把所有的代码都放到了一个表单form，所有只有我们第一行的输入框校验通过，才可以进行add动态的表单项，如果是非必填的话也可以进行add动态表单项，或者不要把第一行的输入框放入form表单里。需要注意这个！！！ 5、接下来是动态添加动态表单项的问题：这里我做了一个显示的判断，只有当我们的专题年份选择有值的时候，月份下拉框才显示有值，这里一般是通过请求数据后set值的。 1234567891011&gt; const handleSelectChange = useCallback(&gt; (index) =&gt; &#123;&gt; const monthArr = [&gt; &#123; id: 1, month: '一月' &#125;,&gt; &#123; id: 2, month: '二月' &#125;,&gt; &#123; id: 3, month: '三月' &#125;,&gt; &#123; id: 4, month: '四月' &#125;&gt; ]&gt; setMonthList(monthArr);&gt; &#125;, [] );&gt; 你也可以一开始就渲染好月份的下拉框值，然后等专题年份有值了再去让他可以选择： 123&gt; &lt;Select style=&#123;&#123; width: "10vw" &#125;&#125; disabled=&#123;!form.getFieldValue('area')&#125;&gt;&gt; &lt;/select&gt;&gt; 然后是动态表单项的表单项名必须是：name={[field.name, 表单项名字]}，最后他们都会给加入到sights这个属性的key值里，对应的是sights: [….] 1234&gt; &lt;Form.List name="sights"&gt;&gt; &#123;/* Form.List 下的字段需要包裹 Form.List 本身的 nam */&#125;&gt; &lt;Form.Item &#123;...field&#125; name=&#123;[field.name, 'subjectYear']&#125; label="专题年份"&gt;&gt; 如果我们动态添加表单项的时候赋初始值，或者插入到头部的时候，需要注意这几点： onClick={() =&gt; handleClickAdd(add, fields)} ，需要把add方法传进去 12345678910111213141516171819202122232425262728&gt; // 处理点击加号，新增&gt; const handleClickAdd = async (add, fields) =&gt; &#123;&gt; console.log('addd.....')&gt; console.log(form.getFieldsValue())&gt; // console.log(form.getFieldValue('sights'));&gt; // console.log(form.getFieldValue('sights').length);&gt; // 这里的下一个元素是undefined，要赋值为最新的&gt; // const oldArr = [...form.getFieldValue('sights')];&gt; // console.log(oldArr)&gt; // 这是最新添加的表单项的值&gt; // const newsObj = form.getFieldValue('sights')[form.getFieldValue('sights').length - 1]&gt; // console.log(newsObj)&gt; // 触发表单校验&gt; const fieldsValue = await form.validateFields();&gt; console.log(fieldsValue);&gt; add(&#123;&gt; names: '我是默认的名字',&gt; contain: "Y"&gt; &#125;, 0)&gt; // add: (defaultValue?: StoreValue, insertIndex?: number) =&gt; void;&gt; // 【源码中：第一个对象是默认值，后面是插入的位置，我这里是0就每次都插在第一个】&gt; /* add(&#123;&gt; // subjectName: newsObj.subjectName || fieldsValue.sights[0].subjectName,&gt; category: newsObj.category || fieldsValue.sights[0].category,&gt; subjectYear: newsObj.subjectYear || fieldsValue.sights[0].subjectYear,&gt; &#125;); */&gt; &#125;&gt; 如果我们想添加的最新一行表单项的值是上一行表单项的值的话这样操作： 12345678910111213141516&gt; // 这里的下一个元素是undefined，要赋值为最新的&gt; const oldArr = [...form.getFieldValue('moveSubjectItems')];&gt; // 这是最新添加的表单项的值&gt; const newsObj = form.getFieldValue('moveSubjectItems')[&gt; form.getFieldValue('moveSubjectItems').length - 1&gt; ];&gt; // console.log(newsObj)&gt; // 触发表单校验&gt; const fieldsValue = await form.validateFields();&gt; // 设置新的专题年份与专题题材为空&gt; add(&#123;&gt; // subjectName: newsObj.subjectName || fieldsValue.moveSubjectItems[0].subjectName,&gt; category: newsObj.category || fieldsValue.moveSubjectItems[0].category,&gt; subjectYear: newsObj.subjectYear || fieldsValue.moveSubjectItems[0].subjectYear,&gt; &#125;);&gt; 参考资料： https://ant.design/components/form-cn/#components-form-demo-dynamic-form-item]]></content>
      <categories>
        <category>antd</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数据类型的判断]]></title>
    <url>%2F2020%2F11%2F16%2Fjs%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[如何判断数据类型? 1、typeof typeof 操作符返回一个字符串，表示未经计算的操作数的类型。 类型 结果 Undefined undefined Null object Boolean boolean Number number BigInt(es2020新增) bigint String string Symbol symbol 宿主对象 取决于具体实现 Function对象 function 其他任何对象 object 12345678910111213141516171819console.log(typeof []) // object []数组的数据类型在 typeof 中被解释为 objectconsole.log(typeof function () &#123;&#125;) // functionconsole.log(typeof &#123;&#125;) // objectconsole.log(typeof undefined) // undefinedconsole.log(typeof null)// object null 的数据类型被 typeof 解释为 objectconsole.log(typeof '1' === 'string') // true 注意内容为数字的字符串仍是字符串;// 【 使用 Array.isArray 或者 Object.prototype.toString.call】// 区分数组和普通对象console.log(Object.prototype.toString.call([1, 3, 4]));//[object Array]console.log(Object.prototype.toString.call(&#123;a: 1&#125;)) //[object Object]console.log(Array.isArray([1, 3, 4]));// trueconsole.log(Array.isArray(&#123;&#125;)) // false// 需要注意几个例子：用new出来的都是object类型// 除 Function 外的所有构造函数的类型都是 'object'console.log(typeof new Number(1) === 'object');//trueconsole.log(typeof new String('abc') === 'object');//trueconsole.log(typeof new Function());// function 1.1 typeof null12// JavaScript 诞生以来便如此console.log(typeof null === 'object');//true 在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签是 0，typeof null 也因此返回 &quot;object&quot; 1.2 语法中的括号123// 括号有无将决定表达式的类型。console.log( typeof 99 + 'pyy');// 'numberpyy'console.log(typeof (99 + 'pyy'))// 'string' 1.3 typeof错误在 ECMAScript 2015 之前，typeof 总能保证对任何所给的操作数返回一个字符串。即便是没有声明的标识符，typeof 也能返回 &#39;undefined&#39;。使用 typeof 永远不会抛出错误 但在加入了块级作用域的 let 和 const 之后，在其被声明之前对块中的 let 和 const 变量使用 typeof 会抛出一个 ReferenceError。块作用域变量在块的头部处于“[暂存死区]”，直至其被初始化，在这期间，访问变量将会引发错误 1.3.1 暂存死区与通过 var 声明的有初始化值 undefined 的变量不同，通过 let 声明的变量直到它们的定义被执行时才初始化。在变量初始化前访问该变量会导致 ReferenceError。该变量处在一个自块顶部到初始化处理的“暂存死区”中 1234567function do_something () &#123; console.log(bar) // undefined console.log(foo) //ReferenceError: Cannot access 'foo' before initialization var bar = 1 let foo = 2&#125; 123456function do_something () &#123; let foo; //通过 let 声明的变量直到它们的定义被执行时才初始化 console.log(foo)//undefined foo = 2&#125; 1.3.2 暂存死区与typeof与通过var声明的变量, 有初始化值 undefined和只是未声明的变量不同的是，如果使用typeof检测在暂存死区中的变量, 会抛出ReferenceError异常: 123456//'undefined'console.log(typeof undeclaredVariable)//ReferenceError: Cannot access 'i' before initializationconsole.log(typeof i)let i = 10 2、instanceof运算符用于检测（构造函数的 prototype 属性）【constructor.prototype】是否出现在某个实例对象的原型链上 12345678910function Car (make, model, year) &#123; this.make = make this.model = model this.year = year&#125;const auto = new Car('Honda', 'Accord', 1998)console.log(auto instanceof Car)// trueconsole.log(auto instanceof Object)// true 1234console.log('abc' instanceof String) // falseconsole.log(function () &#123;&#125; instanceof Function) // trueconsole.log([] instanceof Array) // trueconsole.log(&#123;&#125; instanceof Object) // true 从结果可以看的出只有引用数据类型（Array，Function，Object）可以被判断到，其他的String和Number不能被instanceof判断到 注意：没有用instanceof来判断null和undefined，因为null，undefined不是构造器 3、Object.prototype.toString.call() toString() 方法返回一个表示该对象的字符串。 123456789101112function Dog (name) &#123; this.name = name&#125;//在toString没有被重写的情况下打印：[object Object]const dog1 = new Dog('Gabby')console.log(dog1.toString())//如果重写了Dog.prototype.toString = function dogToString() &#123; return `$&#123;this.name&#125;`;&#125;;console.log(dog1.toString())//Gabby 每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中 type 是对象的类型 3.1 使用toString()检测对象类型可以通过 toString() 来获取每个对象的类型。为了每个对象都能通过 Object.prototype.toString() 来检测，需要以 Function.prototype.call() 或者 Function.prototype.apply() 的形式来调用，传递要检查的对象作为第一个参数， 1234567891011let toString = Object.prototype.toStringtoString.call(123) // [object Number]toString.call('abc') // [object String]toString.call([]) // [object Array]toString.call(function () &#123;&#125;) // [object Function]toString.call(&#123;&#125;) // [object Object]toString.call(undefined) // [object Undefined]toString.call(null) // [object Null]//内置对象类型也能判断toString.call(new String()) // [object String]toString.call(new Date()) // [object Date] 参考资料： https://mp.weixin.qq.com/s/qDT4zBxUT-nYCMyrzc-Yaw https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js预解析和执行过程]]></title>
    <url>%2F2020%2F11%2F15%2Fjs%E9%A2%84%E8%A7%A3%E6%9E%90%E5%92%8C%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一、变量在内存中的存在形式JavaScript中有基本数据类型和引用数据类型。基本数据类型包括：undefined、null、boolean、String、Number；引用数据类型主要是对象（包括{}、[]、Date、Function等）。 1.1 基本类型1234var a = 10;var b = a;b = 20;console.log(a); // 10 从上面的例子，我们可以看出b的值只是a的值的一份拷贝，两个变量的值虽然相等，但是两个变量保存的不同的基本类型的值，b是保存了a的一个副本而已。所以当b改变的时候，a的值是不会改变的，还是10。【基本类型是直接存在栈区】 1.2 引用类型【引用数据类型（对象）是存在堆区，变量只是持有该对象的地址而已】 1234let obj1 = &#123; id: '01', name: 'pyy' &#125;;let obj2 = obj1;obj2.name = '我改名字了';console.log(obj1.name); //'我改名字了' 从上面的例子中，我们声明了obj1，并把obj1赋值给了obj2，然后我们修改Obj2的name属性时，obj1的name属性也跟着修改了，说明这两个引用数据类型变量指向着同一个堆内存的对象，obj1赋值给obj2，实际把这个堆内存对象在栈内存的引用地址复制了一份给了obj2，但它们本质上共同指向了同一个堆内存对象 二、预解析概念：在当前作用域中，JavaScript代码执行之前，浏览器首先会默认的把所有带var和function声明的变量进行提前的声明或者定义。 2.1. 声明和定义var num = 30; 这个代码有两个步骤：声明和定义 声明：var num 就是告诉浏览器在全局作用域中有一个num变量，如果只是声明了没有赋值，默认值就是undefined。 定义：num = 30 就是给变量进行【赋值】 2.2 预解析只发生在当前的作用域下这里有个区别：var声明的变量在预解析的时候只是提前的声明，function声明的函数在预解析的时候会提前声明并且会同时定义 123456789console.log(nn); //undefinedvar nn = 30;console.log(nn);//30sum(100, 200);//300function sum(num1, num2) &#123; var total = num1 + num2; console.log(total);&#125; 一开始只会对window下的全局变量和函数进行预解析，只有等到函数执行的时候才会对函数的变量和函数进行预解析。 上面的例子：第一次输出nn的时候，由于因为预解析，只是声明了并没有定义。所以输出undefined，，第二次输出nn的时候定义了，输出30。函数的声明和定义是同时进行的，所以sum()虽然在function sum函数声明之前调用的，但是依然会可以正常调用，打印300。 三、理解作用域3.1 例子解释当你看见 var a = 2; 这段程序时，很可能认为这是一句声明。 引擎（负责js程序整个的编译和执行过程）并不是这么认为的。事实上，引擎认为这里有两个完全不同的声明，一个由编译器（负责语法分析以及代码生成）在编译时处理，另一个则由引擎在运行时处理。 作用域：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套严格的规划，确定当前执行的代码对这些标识符的访问权限。 事实上编译器会进行如下处理。 遇到 var a ，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a 。 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常！ 总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。 3.2 编译器的术语先科普一下编译器的术语： 在上面的例子中，引擎会为变量 a 进行 LHS 查询。另外一个查找的类型叫作 RHS L”和“R”的含义，它们分别代表左侧和右侧。是一个赋值操作的左侧和右侧。 换句话说：当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。 可以将 RHS 理解成 retrieve his source value（取到它的源值），这意味着“得到某某的值。 LHS 查询则是试图找到变量的容器本身(赋值操作的目标是谁) 1console.log( a ); 其中对 a 的引用是一个 RHS 引用，因为这里 a 并没有赋予任何值。相应地，需要查找并取得 a 的值，这样才能将值传递给 console.log(..) 。 1a = 2; 这里对 a 的引用则是 LHS 引用，因为实际上我们并不关心当前的值是什么，只是想要为 =2 这个赋值操作找到一个目标 1234function foo(a) &#123; console.log( a ); // 2&#125;foo( 2 ); 最后一行 foo(..) 函数的调用需要对 foo 进行 RHS 引用，意味着“去找到 foo 的值，并把它给我”。并且 (..) 意味着 foo 的值需要被执行。 隐式的 a＝2 操作可能很容易被你忽略掉，在 2 被当作参数传递给foo(..) 函数时， 2 会被分配给参数 a 。为了给参数 a （隐式地）分配值，需要进行一次LHS 查询。 这里还有对 a 进行的 RHS 引用，要去找到a的值并且将得到的值传给了 console.log(..) 。 console.log(..) 本身也需要一个引用才能执行，因此会对 【console 对象进行 RHS 查询，并且检查得到的值中是否有一个叫作 log 的方法】 3.3 作用域嵌套作用域是根据名称查找变量的一套规则。 当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。 12345function foo(a) &#123; console.log( a + b );&#125;var b = 2;foo( 2 ); // 4 对 b 进行的 RHS 引用无法在函数 foo 内部完成，但可以在上一级作用域（在这个例子中就是全局作用域）中完成，因为可以在全局作用域中找到b这个变量。 嵌套作用域链的规则：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止 这个建筑代表程序中的嵌套作用域链。第一层楼代表当前的执行作用域，也就是你所处的位置。建筑的顶层代表全局作用域。 LHS 和 RHS 引用都会在当前楼层进行查找，如果没有找到，就会坐电梯前往上一层楼，如果还是没有找到就继续向上，以此类推。一旦抵达顶层（全局作用域），可能找到了你所需的变量，也可能没找到，但无论如何查找过程都将停止。 【注意：如果RHS查询在所有嵌套的作用域中都找不到所需要的变量的话，引擎就会抛出ReferenceError异常。 相比之下，如果执行LHS查询（查找变量对象本身）时，如果在顶层作用域中找不到，它就会在全局作用域中创建一个该名称的变量然后还给引擎，前提是在“非严格模式下” 如果RHS查询找到了变量，但是你对这个变量的值进行不合法的操作，例如：引用Null或者undefined类型的值中的属性，那么引擎会报错异常，叫做TypeError。 ReferenceError和作用域判别失败有关，而TypeError则是代表作用域判别成功了但是你的操作是不合理或者非法的 3.4 总结下作用域就是一套根据名称查找变量的规则，用于确定在何处以及如何去查找变量。如果查找的目的是对变量进行赋值，就会使用LHS查询；如果目的是获取到变量的值，就会使用RHS查询。 js引擎在代码执行前会进行编译，比如：var a = 2: 1、首先，var a在其作用域中声明新的变量。 2、接下来a = 2会进行【LHS查询变量a】并【对其进行赋值】 不成功的 RHS 引用会导致抛出 ReferenceError 异常。 不成功的 LHS 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出ReferenceError 异常（严格模式下）。 四、词法作用域我们来看个例子： 查找过程： 引擎执行 console.log(..) 声明，并查找 a 、 b 和 c 三个变量的引用。 1、它首先从最内部的作用域，也就是 bar(..) 函数的作用域气泡开始查找。引擎无法在这里找到 a 。 2、因此会去上一级到所嵌套的 foo(..) 的作用域中继续查找。在这里找到了 a ，因此引擎使用了这个引用。对 b 来讲也是一样的。而对 c 来说，引擎在 bar(..) 中就找到了它。3、如果 a 、 c 都存在于 bar(..) 和 foo(..) 的内部， console.log(..) 就可以直接使用 bar(..)中的变量，而无需到外面的 foo(..) 中查找 五、函数作用域和块级作用域 JavaScript 具有基于函数的作用域，意味着每声明一个函数都会为其自身创建一个气泡。 123456789function foo(a)&#123; let b = 2; // 一些代码 function bar ()&#123; // ...更多的代码 &#125; let c = 3;&#125;bar();//ReferenceError: bar is not defined 在这个代码片段中， foo(..) 的作用域气泡中包含了标识符 a 、 b 、 c 和 bar 。因此无法从 foo(..) 的外部对它们进行访问。也就是说，这些标识符全都无法从全局作用域中进行访问，因此下面的代码bar()会导致 ReferenceError 错误。 无论标识符声明出现在作用域中的何处，这个标识符所代表的变量或函数都属于所处作用域的气泡。 bar(..) 拥有自己的作用域气泡。 全局作用域也有自己的作用域气泡，它只包含了一个标识符： foo 函数作用域的含义是指：属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用） 5.1 隐藏内部实现 如果从写的代码中挑选出一个任意的片段，然后用函数的声明对它进行包装，实际上就是把这些代码进行隐藏了起来。实际就是在这个代码片段的周围创建了一个作用域气泡。换句话说：可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域来“隐藏”它们 我们应该最小限度地暴露必要内容，而将其他内容都隐藏起来，比如某个模块或者对象的API设计。 123456789function doSomething (a) &#123; b = a + doSomethingElse(a * 2) console.log(b * 3)&#125;function doSomethingElse (a) &#123; return a - 1&#125;var bdoSomething(2) // 15 在上面的代码中，变量b和doSomethingElse应该是doSomething内部具体实现的“私有内容”。但是这样写的话，会给外部作用域对b和doSomethingElse的访问权限造成了不必要，很危险！！！可能会给无意地方式来使用。所以需要合理的设置，如下： 123456789function doSomething (a) &#123; function doSomethingElse (a) &#123; return a - 1 &#125; var b b = a + doSomethingElse(a * 2) console.log(b * 3)&#125;doSomething(2) // 15 修改后的代码，b 和 doSomethingElse(..) 都无法从外部被访问，而只能被doSomething所控制住。 5.2 函数作用域 如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行。JavaScript 提供了能够同时解决这两个问题的方案： 12345678let a = 2;(foo = () =&gt; &#123; // 这里的foo可以省略【函数表达式可以是匿名的】 let a = 3; console.log("foo函数内的:"+a);//3&#125;)();//自动执行函数console.log("全局作用域的:"+a);//2 上述代码中， foo 被绑定在函数表达式自身的函数中而不是所在作用域中。 科普：如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处 12345function foo () &#123; var a = 3 console.log(a) // 3&#125;foo() 这个例子就是：foo被绑定在所在作用域中，可以直接通过foo() 来调用它 两个例子比较一下：换句话说， (function foo(){ .. }) 作为函数表达式意味着 foo 只能在 .. 函数体所代表的位置中被访问，外部作用域则不行 5.3 匿名和具名函数对于函数表达式你最熟悉的可能就是回调参数了，比如： 123setTimeout( function() &#123; console.log("hi!");&#125;, 1000 ); 这叫作匿名函数表达式，因为 function().. 没有名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名 5.3.1 立即执行函数表达式123456var a = 2 (function foo() &#123; var a = 3 console.log(a) // 3 &#125;)();console.log(a) // 2 函数被包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个( ) 可以立即执行这个函数，比如 (function foo(){ .. })() 。第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函数。规定了一个术语：IIFE IIFE另一个非常普遍的进阶用法：把它们当作函数调用并传递参数进去 1234567var a = 2(function IIFE (global) &#123; var a = 3 console.log(a) // 3 console.log(global.a) // 2&#125;)(window)console.log(a) // 2 我们将 window 对象的引用传递进去，但将参数命名为 global。所以可以在内部打印全局变量的a IIFE 还有一种变化的用途是：倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE执行之后当作参数传递进去 1234567(function IIFE (def) &#123; def(window)&#125;)(function def (global) &#123; var a = 3 console.log(a) // 3 console.log(global.a) // 2&#125;) 函数表达式 def 定义在片段的第二部分，然后当作参数（这个参数也叫作 def ）被传递进IIFE 函数定义的第一部分中，最后，参数 def （也就是传递进去的函数）被调用，并将window 传入当作 global 参数的值 5.4 块作用域123for (var i=0; i&lt;10; i++) &#123; console.log( i );&#125; 我们在 for 循环的头部直接定义了变量 i ，通常是因为只想在 for 循环内部的上下文中使用 i ，而忽略了 i 会被绑定在外部作用域（函数或全局）中 123456var foo = trueif (foo) &#123; var bar = 4 * 2 console.log("函数内："+bar)//8&#125;console.log("全局："+bar);//8 ，在外部可以访问到bar 当使用 var 声明变量时，它们最终都会函数作用域和块作用域属于外部作用域 5.4.1 let的出现ES6 改变了现状，引入了新的 let 关键字，提供了除 var 以外的另一种变量声明方式。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react系列01---初见react]]></title>
    <url>%2F2020%2F11%2F08%2Freact01%2F</url>
    <content type="text"><![CDATA[开发React必须依赖三个库： react：包含react所必须的核心代码 react-dom：react渲染在不同平台所需要的核心代码 babel：将jsx转换成React代码的工具 如何添加这三个依赖： 方式一：直接CDN引入 react依赖：https://unpkg.com/react@16/umd/react.development.js react-dom依赖：https://unpkg.com/react-dom@16/umd/react-dom.development.js babel依赖：https://unpkg.com/babel-standalone@6/babel.min.js 方式二：下载后添加本地依赖 方式三：通过npm管理 Hello World下面我们通过一个hello world的案例来实现以下： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;Header&lt;/div&gt; &lt;div id="app"&gt;dafdasf&lt;/div&gt; &lt;div&gt;Footer&lt;/div&gt; &lt;!-- 添加React的依赖 --&gt; &lt;script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/babel-standalone@6/babel.min.js"&gt;&lt;/script&gt; &lt;!-- crossorigin:因为我们引用了远程的js文件，文件内部可能代码有问题。如果希望在本地这里显示出来错误。 --&gt; &lt;!-- 注意事项: 使用jsx, 并且希望script中的jsx的代码被解析, 必须在script标签中添加一个属性 --&gt; &lt;script type="text/babel"&gt; // &lt;h2&gt;&lt;/h2&gt;: jsx代码 let message = "Hello World"; ReactDOM.render(&lt;h2&gt;&#123;message&#125;&lt;/h2&gt;, document.getElementById("app")) //render(渲染内容，挂载的对象【一般给个id】)，渲染的内容就会覆盖掉id='app'的内容 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ReactDOM.render函数： 定义一个id为app的div 这里我们传入了一个h2元素 参数一：传递要渲染的内容，这个内容可以是HTML元素 / React的组件 参数二：将渲染的内容，挂载到哪一个HTML元素上 helloword按钮的实现123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;Header&lt;/div&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;div&gt;Footer&lt;/div&gt; &lt;!-- 添加React的依赖 --&gt; &lt;script src="../importjs/react.development.js"&gt;&lt;/script&gt; &lt;script src="../importjs/react-dom.development.js"&gt;&lt;/script&gt; &lt;script src="../importjs/babel.min.js"&gt;&lt;/script&gt; &lt;!-- 注意事项: 使用jsx, 并且希望script中的jsx的代码被解析, 必须在script标签中添加一个属性 --&gt; &lt;script type="text/babel"&gt; // jsx特点：多个标签最外层（根）只能有一个标签 let message = "Hello World"; function btnClick()&#123; message = '我被改变了的内容...'; //message不会同时更新的，只有重新渲染才能 //更新数据需要重新渲染一次 render(); &#125; function render()&#123; ReactDOM.render( &lt;div&gt; &lt;h2&gt;&#123;message&#125;&lt;/h2&gt; &lt;button onClick=&#123;btnClick&#125;&gt;改变文本&lt;/button&gt; &lt;/div&gt;, document.getElementById("app")) &#125; render(); // 页面加载时渲染一次dom &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; helloworld组件式实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;!-- 添加React的依赖 --&gt; &lt;script src="../importjs/react.development.js"&gt;&lt;/script&gt; &lt;script src="../importjs/react-dom.development.js"&gt;&lt;/script&gt; &lt;script src="../importjs/babel.min.js"&gt;&lt;/script&gt; &lt;script type="text/babel"&gt; // 我们想把message和按钮封装成一个组件叫做App class App extends React.Component&#123; constructor()&#123; super(); //必须先调用下super，初始化父类的实例，才能使用this // this.message = 'hellow world' //在构造函数声明了message，别的地方才可以this.message使用 //如果想更改数据时，页面也跟着改变数据。要定义在state里 this.state = &#123; message:'hello,world' &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;h2&gt;&#123;this.state.message&#125;&lt;/h2&gt; &lt;button onClick=&#123;this.btnClick.bind(this)&#125;&gt;改变文本&lt;/button&gt; &lt;/div&gt; ) &#125; btnClick()&#123; console.log('按钮发生了点击..'); console.log(this);//undefined /* 内部回调的时候拿不到this。 btnClick.apply(undefined) this.message = '改变后的内容...' Cannot set property 'message' of undefined */ /* this.render(); 这里调用render没用，相当于把render函数的 返回值返回给你 。虚拟dom不知道你要生成最新的jsx。不要手动调用render() */ this.setState(&#123; message:'66666' &#125;) //这里有点像小程序。内部会进行更新操作 &#125; &#125; ReactDOM.render( &lt;App/&gt;, document.getElementById("app")) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用类的方式封装组件： render当中返回的jsx内容，就是之后React会帮助我们渲染的内容 1、定义一个类，继承自React.Component 2、实现当前组件的render函数 参与界面更新的数据我们也可以称之为是参与数据流，这个数据是定义在当前对象的state中 1、我们可以通过在构造函数中 this.state = {定义的数据} 2、数据发生变化时，可以调用 this.setState 来更新数据，并且通知React进行update操作 3、在进行update操作时，就会重新调用render函数，并且使用最新的数据，来渲染界面 事件绑定中的this 类中直接定义一个函数，并且将这个函数绑定到html原生的onClick事件上，当前这个函数的this指向的是谁呢？———–默认情况下是undefined。这次因为React并不是直接渲染成真实的DOM，我们所编写的button只是一个语法糖，它的本质React的Element对象]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6总结常用]]></title>
    <url>%2F2020%2F09%2F10%2Fes6(1)%2F</url>
    <content type="text"><![CDATA[总结一下es6常用的语法1、（解构）只要等号两边模式一致，左边变量即可获取右边对应位置的值12345678910111213141516171819let [ , , c] = [1, 2, 3]; console.log(c); // 3 let [a1, , c1] = [1, 2, 3]; console.log(a1,c1); // 1, 3 let [a2, ...b2] = [1, 2, 3]; console.log(a2,b2); // 1, [2,3] let [a, b, ..c.] = [1]; console.log(a, b, c); // 1, undefined, [] 【如果解构不成功，变量的值就等于undefined。】 let [a] = []; // a =&gt; undefined let [a, b] = [1]; // a =&gt; 1 , b =&gt; 【 注意：两边模式不同时，会报错：】 例子：let [a] =1 ;let [a] =false; let [a] =NaN ; let [a] = null; let [a] = &#123;&#125;; 1.2、数组指定解构的默认值，左边声明默认值，如果右边没赋值就取默认： 123456789let [a = 1] = []; // a =&gt; 1let [a, b = 2] = [a]; // a =&gt; 1 , b =&gt; 2【注意：有两个特殊情况：**【1、右边模式对应的值，必须严格等于undefined，默认值才能生效；2、而null不严格等于undefined 】let [a = 1] = [undefined]; // a =&gt; 1let [a = 1] = [null]; // a =&gt; null 2、对象的解构赋值：只要按照变量名去取对应属性名的值，12345678 let &#123;a, b&#125; = &#123;a:1, b:2&#125;; // a =&gt; 1 , b =&gt; 2 let &#123;a&#125; = &#123;a:3, b:2, c:1&#125;;// a =&gt; 3 let &#123;a&#125; = &#123;b:2, c:1&#125;; // a =&gt; undefined【注意：如果我们想赋值给新的变量： let &#123;a:b&#125; = &#123;a:1, c:2&#125;; console.log(&#123;b&#125;); //&#123;b: 1&#125; 先找到a的属性名，然后赋值，再赋值给b】 2.1:对象指定解构的默认值： 1234567891011121314151617 let &#123;a=1&#125; = &#123;&#125;; // a =&gt; 1let &#123;a, b=1&#125; = &#123;a:2&#125;; // a =&gt; 2, b =&gt; 1let &#123;a:b=3&#125; = &#123;&#125;; // b =&gt; 3let &#123;a:b=3&#125; = &#123;a:4&#125;; // b = &gt;4// 【a是匹配模式，b是变量】let &#123;a=1&#125; = &#123;a:undefined&#125;; // a =&gt; 1let &#123;a=1&#125; = &#123;a:null&#125;; // a =&gt; null// 因为null与undefined不严格相等，所以赋值有效let obj = &#123; a:[ 1, &#123; b: 2&#125;]&#125;;let &#123;a, a: [c, &#123;b&#125;]&#125; = obj;//对象的数组只有c和1对应的上，然后// a=&gt;[1, &#123;b: 2&#125;], b =&gt; 2, c =&gt; 1 3、字符串的解构赋值中，有个Key为length可以得到转换成数组的长度1234let &#123;length:len&#125; = &apos;hello&apos;;// len =&gt; 5 console.log(len); let &#123;length:len1&#125; = [1,2,3,4,5,6,7,7]; console.log(len1);//8 4、数值和布尔值的解构赋值【只要等号右边的值不是对象或数组，就先将其转为对象】【undefined和null无法转为对象，所以对它们进行解构赋值，都会报错】1234567891011let &#123;length:len&#125; = &apos;hello&apos;;// len =&gt; 5 console.log(len); let &#123;length:len1&#125; = [1,2,3,4,5,6,7,7]; console.log(len1);//8 let &#123;toString: s&#125; = 123; //包装对象有toString属性 console.log(s === Number.prototype.toString)//true 【undefined和null无法转为对象，所以对它们进行解构赋值】 let &#123; prop: x &#125; = undefined; // TypeError 5、函数参数的解构赋值1234function fun ([a, b])&#123; return a + b; &#125; fun ([2, 3]); // 5 5.1：默认值的解构: 123456789function fun (&#123;a=0, b=0&#125; = &#123;&#125;)&#123; //参数右边= &#123;&#125; 等价于这两句： //【 let aa = &#123;&#125;; fun(aa)】 return [a, b]; &#125; fun (&#123;a:1, b:2&#125;);// [1, 2] fun (&#123;a:1&#125;); // [1, 0] fun (&#123;&#125;); // [0, 0] fun (); // [0, 0] 6、【应用1：函数返回多个值】：123456789101112131415161718192021222324252627282930313233343536373839404142434445 // 【返回一个数组】 function f ()&#123; return [1, 2, 3]; &#125; let [a, b, c] = f(); // a=&gt;1, b=&gt;2, c=&gt;3 //【 返回一个对象】常用 function f ()&#123; return &#123;a:1, b:2&#125;; &#125; let &#123;a, b&#125; = f(); // a=&gt;1, b=&gt;2 //【快速的将一组参数与变量名对应】常用 function f([a, b, c]) &#123; console.log(&apos;&apos;+a+&quot;,&quot;+b); &#125; f([1, 2, 3]);//1,2 function f2(&#123;age=990,name&#125;) &#123; console.log(&apos;&apos;+age+&quot;,&quot;+name); &#125; f2(&#123;age:18,name:&apos;lixun&apos;&#125;);//18,lixun f2(&#123;name:&apos;lixun&apos;&#125;);//990,lixun 没传age就用默认的990 //【提取JSON数据：】 let json1 = &#123; name : &apos;lixun&apos;, age: 19 &#125; let &#123;name, age&#125; = json1; // lixun,19 //【遍历Map结构】 const m = new Map(); m.set(&apos;aa&apos;,1); m.set(&apos;bb&apos;,2); for (let [k, v] of m)&#123; console.log(k + &apos; : &apos; + v); &#125; // 【获取键的名称】 for (let [k] of m)&#123; console.log(k); &#125; // 获取值的名称：for (let [,k] of m)//【导入模块的指定方法】常用】 const &#123;add&#125; = require(&apos;Math&apos;); 7、字符串的拓展 1234567891011let a = &apos;hello lx&apos;;a.startsWith(&apos;lx&apos;); // false 【是否找到参数字符串】a.endsWith(&apos;x&apos;); // truea.includes(&apos;lx&apos;); // true 【这三个方法都支持第二个参数，表示起始搜索的位置】。 let a = &apos;hellolxhahahah&apos;; console.log(a.includes(&apos;lx&apos;,8)); // false 【repeat方法返回一个新字符串，表示将原字符串重复n次】 &apos;abc&apos;.repeat(3); // &apos;abcabcabc&apos; 8、模版字符串123let v1 = &apos;zhh&apos;; // 【拼接变量】 let a = `abc$&#123;v1&#125;def` 9、正则的拓展【第一个参数：字符串，第二个参数：正则的修饰符12345678let a = new RegExp(&apos;aaa&apos;, &apos;i&apos;);// 等价于let a = /aaa/i;【只能有一个参数：正则表达式】let a = new RegExp(/abc/i);//等价于let a = /abx/i; 10、数值：Number.parseInt(), Number.parseFloat()方法12345678910111213141516171819202122232425 parseInt(&apos;123.34&apos;); // 123 parseFloat(&apos;123.456#&apos;); // 123.456 Number.parseInt(&apos;12.345&apos;); // 12 Number.parseFloat(&apos;123.456##&apos;); // 123.456 【用来判断一个数值是否是整数： Number.isInteger】 Number.isInteger(10); // true Number.isInteger(10.0); // true 【Math.trunc:去除小数的小数部分，返回整数。 1、 若为非数值，先转为数值。 2、 为空值或无法截取整数的值，返回NaN】 console.log(Math.trunc(1.1)); //1 console.log(Math.trunc(true)); //1 console.log(Math.trunc(NaN)); //NaN 【Math.sign():判断一个数是正数、负数还是零；非数值，会先转成数值 正数返回+1，负数返回-1，为0返回0，其他返回NaN】 Math.sign(-1); // -1 Math.sign(1); // +1 Math.sign(0); // 0 Math.sign(NaN); // NaN Math.sign(true); // +1 Math.sign(false);// 0 11、函数拓展，默认值1234567891011121314151617181920212223242526【参数变量是默认声明的，不能用let和const再次声明： function f(a1, b1=&apos;lx&apos;)&#123; console.log(a1, b1); &#125; f(&apos;hii&apos;)//hii lx f(&apos;hii&apos;,&apos;zhh&apos;)//hii zhh 与解构赋值默认值结合使用： function f (&#123;a, b=1&#125;)&#123; console.log(a,b) &#125;; f(&#123;&#125;); // undefined 1 f(&#123;a:2&#125;); // 2 1 f(&#123;a:2, b:3&#125;); // 2 3 f(); // 报错 【rest参数只能放在最后一个】 function f2 (a,...b)&#123; console.log(f2.length);//1 &#125;;//函数的length属性不包含rest参数 f2(1,[2,3,4]); // 1 function f22 (a,b,c)&#123; console.log(f22.length);//3 &#125;; f22(234,4,5) 12、【扩展运算符】重要!12345678910111213141516171819202122232425例子1 ： let a = [1, 2, 3, 4, 5] console.log(a); //[ 1, 2, 3, 4, 5 ] console.log(...a); // 1, 2, 3, 4, 5 例子2 ： let a = [1, 2, 3] let b = [1, 4] let c = [...a, ...b] console.log(c); // [1,2,3,1,4] 例子3 ：let obj1 = &#123; &quot;name&quot;: &quot;lx&quot;, &quot;age&quot;: 18, &quot;sex&quot;: &quot;nan&quot; &#125; let obj2 = &#123; &quot;name&quot;: &quot;zhh&quot;, &quot;age&quot;: 28 &#125; let obj3 = &#123; ...obj1, ...obj2 &#125; console.log(obj3); //如果有相同属性Key，后面的会把前面的覆盖掉 //&#123;name: &quot;zhh&quot;, age: 28, sex: &quot;nan&quot;&#125; 【扩展运算符应用1：数组扩展为对象】123456789 let a = [11, 22, 33] let b = [2, 44,55,66] let c = &#123; ...a, ...b &#125;console.log(c);//&#123;0: 2, 1: 44, 2: 55, 3: 66&#125;//以a和b长的那个数组为新的数组长度，然后后面的...b会覆盖相同//索引上的...a上。这里2会覆盖11，44覆盖22，以此类推.. 【扩展运算符应用2：添加属性、在克隆的同时添加额外的属性】重要▲1234const user = &#123;id:02,name:&apos;lxx&apos;&#125;;const userNew = &#123;...user,sex:&apos;woman&apos;&#125;console.log(userNew);//&#123;id: 2, name: &quot;lxx&quot;, sex: &quot;woman&quot;&#125; 【扩展运算符应用3：合并两个对象为一个新的对象】1234567 const part1 = &#123; id: 11, name: &apos;pengyuyan&apos; &#125; const part2 = &#123; id: 12, password: &apos;wuyanzu&apos; &#125; const user1 = &#123; ...part1, ...part2 &#125; console.log(user1);// &#123; id: 12, name: &quot;pengyuyan&quot;, password: &quot;wuyanzu&quot; &#125; 也可以用这种写法： const user = &#123; ...p1, ...&#123; id: 12, password: &apos;wuyanzu&apos; &#125; &#125; 【扩展运算符应用4：利用…删除对象的属性】1234567891011121314151617 let student = &#123; age: 18, name: &apos;kysue&apos;, sex: &quot;男&quot; &#125; const noAge = (&#123; age, ...params &#125;) =&gt;rest; let re1 = noAge(student);【//你可以看成&#123;age,...rest&#125;=&#123;age:18,name:&apos;kysue&apos;,sex:&apos;男&apos;&#125;】【//因为age对应到了，所以剩下的拓展rest就是除了age以外的所有属性。】 console.log(params);//过滤掉了age的属性 【let getFullName = (&#123;first, last&#125;) =&gt; first + &apos; &apos; + last function getFullName(str) &#123; let &#123;first, last&#125; = str; return first + &apos; &apos; + last; &#125; 】 这个例子很重要！！常用 【扩展运算符应用5：属性排序】12345678910111213141516 const user3 = &#123; password: &apos;Password&apos;, name: &apos;lx&apos;, id: 33 &#125; //可以将属性放到顶部或者底部 //先添加 key: undefined 到新对象，从而将 key 移到最前面 const organize = object =&gt; (&#123; id: undefined, ...object &#125;);//object是参数，后面是return (&#123; id: undefined, ...object &#125;)。他简便写法 let rs1 = organize(user3); console.log(rs1); //【如果想把解构出来的password属性放最后可以这样： const org = (&#123; password, ...obj &#125;) =&gt;(&#123; ...obj, password &#125;) //【想让默认值放到首位也可以这样写】 const setDefa = (&#123; ...obj&#125;) =&gt; (&#123; shuzu: [], ...obj &#125;) 【扩展运算符应用6：重命名属性】1234567const rename = (&#123; ID, ...obj &#125;) =&gt; (&#123; iid: ID, ...obj &#125;) const user = &#123; ID: 500, name: &quot;lxx&quot; &#125; //返回重命名属性的时候，左边iid是新的属性名，右边ID是值 console.log(rename(user)) //&#123;iid: 500, name: &quot;lxx&quot;&#125; 【扩展运算符应用7：替代apply方法】 1234567891011121314 // ES6之前 function f(a, b, c) &#123; console.log(&#123;a,b,c&#125;); &#125;; var a = [1, 2, 3]; f.apply(null, a); // ES6之后 f(...aaa);// ES6之前:由于 JavaScript 数组没有 max() 方法，因此您可以应用 Math.max() 方法//第一个参数（null）无关紧要,传什么都可以，最终返回都是6 Math.max.apply(null, [3, 2, 6]); // ES6之后 Math.max(...[3, 2, 6]); 【扩展运算符应用8：实现深拷贝, 拓展运算符 深拷贝】12345let a1 = [1,2] let a2 =[...a1]; a2[0] = 520; console.log(a1,a2); // [1, 2] [520, 2] 13、 Array.from()方法：将类数组对象和可遍历的对象转成真正的数组12345678910 let a = &#123; &apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, length: 2 &#125; let arr = Array.from(a);【Array.of():将一组数值，转换成数组】 let res = Array.of(1,2,3) console.log(res); 14、 find()和findIndex() 1234567find():用于找出【第一个符合】条件的数组成员,没有一个符合则返回undefined let res = [1, 2, 3, 4, 5].find((value, index, arr) =&gt; &#123; //当前值、当前位置和原数组 return value &gt; 4 &#125;); findIndex():返回找到的元素的索引值。 15、entries(),keys(),values() entries()对键值对遍历，keys()对键名遍历，values()对键值遍历。 for (let i of [&apos;a&apos;, &apos;b&apos;].keys()) { console.log(i)// 0 1 } 16、对象的简洁表示：123456789101112131415161718192021let b =&#123;a&#125; 等价于 let b = &#123;a:a&#125;function f (a,b)&#123; return &#123;a,b&#125;&#125; 等价于：function f (a, b)&#123; return &#123;a:a ,b:b&#125;;&#125;let a =&#123; fun()&#123; alert(&apos;hi&apos;) &#125;&#125;等价于：let a =&#123; fun:function()&#123; alert(&apos;hi&apos;) &#125;&#125; 17、Object.assign()用于对象的合并，将原对象的所有可枚举属性复制到目标对象。1234567891011121314【 用法1：第一个参数:目标对象，第二个参数，源对象。】 let a = &#123;aa:1&#125;; let b = &#123;bb:2&#125;; Object.assign(a,b); //&#123;aa: 1, bb: 2&#125; let a = &#123; a: 1, b: 2 &#125;; let b = &#123; b: 3, c: 4 &#125;; console.log( Object.assign(a, b)); //&#123;a: 1, b: 3, c: 4&#125; 如果有同名，后面的会覆盖前面的 【 用法2：复制一个对象】 const obj = &#123; a: 1 &#125;; const copy = Object.assign(&#123;&#125;, obj); console.log(copy); // &#123; a: 1 &#125; 18、【Set数据结构类似数组，但所有成员的【值唯一】123456789101112131415161718192021222324252627【去掉重复的值】 let a = new Set(); [1,2,3,4,1,5,7,7].forEach(v=&gt;a.add(v)); for (const k of a) &#123; console.log(k); &#125; 【例子1：】 数组去重： [...new Set([1,2,3,4,1,7])] Array.from(new Set([1,2,3,4,1,5,6])) 注意：向Set中添加值的时候，不会类型转换，即6和&apos;6&apos;是不同的 console.log([...new Set([6, &apos;6&apos;])]);//[6, &quot;6&quot;] 【 filter 过滤】 let a = new Set([1, 2, 3, 4]); let c = new Set([...a].filter(x =&gt; (x % 2) == 0)); console.log(c);//Set(2) &#123;2, 4&#125; let a = new Set();【has()表示该值是否为Set的成员】 a.add(1).add(2); // a =&gt; Set(2) &#123;1, 2&#125; a.has(2); // true a.has(3); // false 【可以使用for...of直接遍历Set。】 let a = new Set([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]); for(let k of a)&#123;console.log(k)&#125;; 19、map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果12345678var array1 = [1, 4, 9, 16]; const map1 = array1.map(x =&gt; &#123; if (x == 4) &#123; return x * 2; &#125; return x; &#125;);console.log(map1);//(4) [1, 8, 9, 16] 20、Map类型，值—值，使得各种类型的值(包括对象)都可以作为键123456789101112131415161718let a =new Map();let bb = &#123;name:&apos;pyy&apos;&#125;a.set(bb,&quot;my lix&quot;);console.log(a.get(bb));console.log(a.has(&quot;cc&quot;));//false【 let a = new Map(); a.set(0, &quot;zero&quot;); a.set(1, &quot;one&quot;) for (let i of a.values()) &#123; console.log(i); &#125;; // zero for (let i of a.entries()) &#123; console.log(i); &#125;; // [0, &quot;zero&quot;] a.forEach((v, k, m) =&gt; &#123; console.log(`key:$&#123;k&#125;,value:$&#123;v&#125;,map:$&#123;m&#125;`) // key: 0, value: zero, map: [object Map] &#125;) 】 场景1：当我们在request传参的时候，想在header基础上带上其他参数：1234567function request(params)&#123; let header1 = &#123;...params.header&#125;; header1[&apos;Author&apos;] = &apos;author8888&apos;; console.log(header1); //&#123;style: &quot;css&quot;, Author: &quot;author8888&quot;&#125;&#125;request(&#123;url:&quot;/my/title&quot;,header:&#123;style:&quot;css&quot;&#125;&#125;)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户认证与授权]]></title>
    <url>%2F2019%2F05%2F01%2Fxuecheng3%2F</url>
    <content type="text"><![CDATA[什么是有状态的登陆？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解释：服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，例如tomcat的session。 用户登陆后，我们把登陆者的信息保存在服务端session中，并赋给用户一个cookie值，记录对应的session。然后下次请求，用户携带cookie请求，我们就能识别到对应的session，从而找到用户的信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;缺点：服务端需要存大量数据，增加服务端压力，客户端请求依赖服务端 什么是无状态的登陆？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微服务集群中的每个服务，对外提供的都是Rest风格的接口。而Rest风格的一个最重要的规范就是：服务的无状态性，即： 1 ): 服务端不保存任何客户端请求者信息 2 ): 客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份 加密算法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解释：加密技术是对信息进行编码和解码的技术，编码是把明文译成密文，其逆过程就是解码（解密） 1 ):对称加密，如AES；基本原理：将明文分成N个组，然后使用密钥对各个组进行加密，形成各自的密文，最后把所有的分组密文进行合并，形成最终的密文。 2 ):非对称加密，如RSA ；基本原理：同时生成两把密钥：私钥和公钥，私钥隐秘保存，公钥可以下发给信任客户端，私钥加密，持有私钥或公钥才可以解密，公钥加密，持有私钥才可解密 3 ):不可逆加密，如MD5，SHA； 基本原理：加密过程中不需要使用密钥，输入明文后由系统直接经过加密算法处理成密文，这种加密后的数据。是无法被解密的，无法根据密文推算出明文 token是识别客户端身份的唯一标示，采用何种方式加密才是安全可靠的呢？答：我们将采用JWT + RSA非对称加密 OAuth2允许不同的客户端通过认证和授权的形式访问被保护起来的资源。有这三种角色： 1 ): 授权服务器：对用户身份进行认证，对访问资源进行授权 2 ): 资源服务器：存储资源的服务器 3 ): 客户端：需要通过用户的授权去请求资源服务器的资源，例如：微信客户端 4 ): 资源拥有者：通常为用户，也可以是应用程序 Oauth2接入资源服务进行授权配置 1 ): 1、配置公钥：认证服务生成令牌采用非对称加密算法，认证服务采用私钥加密生成令牌，对外向资源服务提供公钥，资源服务使用公钥来校验令牌的合法性。 2 ): 将公钥拷贝到 publickey.txt文件中，将此文件拷贝到资源服务工程的classpath下 3 ): 加入依赖 4 ): 在config包下创建ResourceServerConfig类：测试发现：请求时携带令牌：在http header中添加 Authorization： Bearer 令牌： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该项目中Oauth2采用的是密码模式，通过用户名和密码即可申请令牌。申请流程如下 1 ): Post请求：http://localhost:40400/auth/oauth/token 2 ): 需要这几个参数： grant_type:填写password，表示密码模式 username：账号 password：密码 redirect_uri:申请授权码时跳转的url &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端Id和客户端密码会匹配数据库oauth_client_details表中的客户端id及客户端密码↓↓ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;申请令牌成功的几个参数：↓↓ 1 ): access_token：访问令牌,完整的令牌 2 ): token_type：0建议Oauth2采用 Bearer Token 3 ): refresh_token:刷新令牌 4 ): expires_in:过期时间 5 ): scope:与定义的客户端范围一致 6 ): jti：身份令牌（短的令牌） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 刷新令牌：当令牌快过期时重新生成一个令牌，刷新令牌不需要授权码也不需要账号和密码，只需要一个刷新令牌、客户端id和客户端密码 1 ): Post：http://localhost:40400/auth/oauth/token 2 ): grant_type ： 固定为 refresh_token 3 ): refresh_token：刷新令牌 JWT研究在没有jwt令牌之前的校验方法：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 问题所在：在传统授权，用户每次请求资源服务，资源服务都需要携带令牌访问认证服务去校验令牌的合法性，并根据令牌获取用户的相关信息，性能低下。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 解决方法：使用JWT的思路是，用户认证通过会得到一个JWT令牌，JWT令牌中已经包括了用户相关的信息，客户端只需要携带JWT访问资源服务，资源服务根据事先约定的算法自行完成令牌校验，无需每次都请求认证服务完成授权 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jwt（JSON风格轻量级的授权和身份认证规范）是一种开放的标准，标准就是将各个主体的信息包装成json对象，主体信息是通过数字签名进行加密和验证，常使用HMAC算法或者RSA对JWT进行签名。JWT包含三部分： 1 ): Header：头部，通常头部有两部分信息：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;声明类型，这里是JWT &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 加密算法，自定义 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们会对头部进行base64加密（可解密），得到第一部分数据 2 ): Payload：载荷，就是有效数据，一般包含下面信息：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户身份信息和声明claim（注意，这里因为采用base64加密，可解密，因此不要存放敏感信息）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注册声明：如token的签发时间，过期时间，签发人等&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这部分也会采用base64加密，得到第二部分数据 3 ): Signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥，通过加密算法生成。用于验证整个数据完整和可靠性 格式如下： 生成私钥和公钥 查询证书信息：Keytool –list –keystore xc.keystore 导出公钥 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把Public key复制出来，删掉换行弄成一行 使用代码通过私钥生成jwt令牌1234567891011121314151617181920212223242526272829303132//生成一个jwt令牌@Testpublic void testCreateJwt()&#123; //证书文件 String key_location = &quot;xc.keystore&quot;; //密钥库密码 String keystore_password = &quot;xuechengkeystore&quot;; //访问证书路径 ClassPathResource resource = new ClassPathResource(key_location); //密钥工厂 KeyStoreKeyFactory keyStoreKeyFactory = new KeyStoreKeyFactory(resource,keystore_password.toCharArray()); //密钥的密码，此密码和别名要匹配 String keypassword = &quot;xuecheng&quot;; //密钥别名 String alias = &quot;xckey&quot;; //密钥对（密钥和公钥） KeyPair keyPair = keyStoreKeyFactory.getKeyPair(alias,keypassword.toCharArray()); //私钥 RSAPrivateKey aPrivate = (RSAPrivateKey) keyPair.getPrivate(); //定义payload信息 Map&lt;String, Object&gt; tokenMap = new HashMap&lt;&gt;(); tokenMap.put(&quot;id&quot;, &quot;123&quot;); tokenMap.put(&quot;name&quot;, &quot;mrt&quot;); tokenMap.put(&quot;roles&quot;, &quot;r01,r02&quot;); tokenMap.put(&quot;ext&quot;, &quot;1&quot;); //生成jwt令牌 Jwt jwt = JwtHelper.encode(JSON.toJSONString(tokenMap), new RsaSigner(aPrivate)); //取出jwt令牌 String token = jwt.getEncoded(); System.out.println(&quot;token=&quot;+token);&#125; 12345678910111213141516171819202122232425//资源服务使用公钥验证jwt的合法性，并对jwt解码 @Test public void testVerify()&#123; //jwt令牌 String token=&quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHQiOiIxIiwicm9sZXMiOiJyMDEscjAyIiwibmFtZSI6Im1ydCIsImlkIjoiMTIzIn0.KK7_67N5d1Dthd1PgDHMsbi0UlmjGRcm_XJUUwseJ2eZyJJWoPP2IcEZgAU3tUaaKEHUf9wSRwaDgwhrwfyIcSHbs8oy3zOQEL8j5AOjzBBs7vnRmB7DbSaQD7eJiQVJOXO1QpdmEFgjhc_IBCVTJCVWgZw60IEW1_Lg5tqaLvCiIl26K48pJB5f‐le2zgYMzqR1L2LyTFkq39rG57VOqqSCi3dapsZQd4ctq95SJCXgGdrUDWtD52rp5o6_0uq‐mrbRdRxkrQfsa1j8C5IW2‐T4eUmiN3f9wF9JxUK1__XC1OQkOn‐ZTBCdqwWIygDFbU7sf6KzfHJTm5vfjp6NIA&quot;; //公钥 String publickey = &quot;‐‐‐‐‐BEGIN PUBLIC KEY‐‐‐‐‐MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAijyxMdq4S6L1Af1rtB8SjCZHNgsQG8JTfGy55eYvzG0B/E4AudR2prSRBvF7NYPL47scRCNPgLnvbQczBHbBug6uOr78qnWsYxHlW6Aa5dI5NsmOD4DLtSw8eX0hFyK5Fj6ScYOSFBz9cd1nNTvx2+oIv0lJDcpQdQhsfgsEr1ntvWterZt/8r7xNN83gHYuZ6TM5MYvjQNBc5qC7Krs9wM7UoQuL+s0X6RlOib7/mcLn/lFLsLDdYQAZkSDx/6+t+1oHdMarChIPYT1sx9Dwj2j2mvFNDTKKKKAq0cv14Vrhz67Vjmz2yMJePDqUi0JYS2r0iIo7n8vN7s83v5uOQIDAQAB‐‐‐‐‐END PUBLIC KEY‐‐‐‐‐&quot;; //校验jwt Jwt jwt = JwtHelper.decodeAndVerify(token, new RsaVerifier(publickey)); //获取jwt原始内容 String claims = jwt.getClaims(); //jwt令牌 String encoded = jwt.getEncoded(); System.out.println(encoded); &#125; 该项目中：用户登录的流程图如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行流程：1、用户登录，请求认证服务2、认证服务认证通过，生成jwt令牌，将jwt令牌及相关信息写入Redis，并且将身份令牌写入cookie(Access_token是完整的jwt令牌，refresh_token是刷新令牌。Jti:是简短的用户身份令牌，在redis存access_token，在cookie存的是jti。)3、用户访问资源页面，带着cookie到网关4、网关从cookie获取token，并查询Redis校验token,如果token不存在则拒绝访问，否则放行5、用户退出，请求认证服务，清除redis中的token，并且删除cookie中的token&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用redis存储用户的身份令牌有以下作用：1、实现用户退出注销功能，服务端清除令牌后，即使客户端请求携带token也是无效的。2、因为jwt完整的令牌太长了，前端如果需要用jwt令牌，可以携带身份令牌jti去请求认证服务拿的jwt长令牌。短的令牌存到cookie，前端携带短的令牌访问网关，拿着短令牌去redis查到对应的长令牌，用户对应的信息，进行校验，如果查到了没过期，就允许继续访问，否则拒绝访问！！！ 认证服务的业务流程如下：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前端认证请求去到 认证服务ucenter-auth，认证服务要去申请令牌，会请求到spring security去申请到令牌，然后security是基于oauth2的协议，可以走密码方式认证。security会去调用UserDetailServiceImpl的方法 。如果这个方法返回的是空的，代表账号不存在；不是空就得到数据库正确的密码，会把密码和权限通通封装成userJwt的对象，该类是扩展类，我们准备存储用户的类型，头像，公司id等等。Security接下里就会比较返回的UserDetails里的密码和前端输入的密码是否一致，如果一致就发放令牌；否则就提示凭证错误 通过RestTemplate请求Spring Security所暴露的申请令牌接口来申请令牌认证服务会把自己注册到eureka，可能是个集群！！建议从eureka中获取认证服务地址请求的body里面有数据，头信息也有数据。Httpentity可以设置Body和headers 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@SpringBootTest@RunWith(SpringRunner.class)public class TestClient &#123; @Autowired LoadBalancerClient loadBalancerClient; @Autowired RestTemplate restTemplate; @Test public void testClient()&#123; //采用客户端负载均衡，从eureka获取认证服务的ip 和端口 ServiceInstance serviceInstance =loadBalancerClient.choose(XcServiceList.XC_SERVICE_UCENTER_AUTH); URI uri = serviceInstance.getUri(); String authUrl = uri+&quot;/auth/oauth/token&quot;; //URI url, HttpMethod method, HttpEntity&lt;?&gt; requestEntity, Class&lt;T&gt; responseType // url就是 申请令牌的url /oauth/token //method http的方法类型 //requestEntity请求内容 //responseType，将响应的结果生成的类型 //请求的内容分两部分 //1、header信息，包括了http basic认证信息 MultiValueMap&lt;String, String&gt; headers = new LinkedMultiValueMap&lt;String, String&gt;(); String httpbasic = httpbasic(&quot;XcWebApp&quot;, &quot;XcWebApp&quot;); //&quot;Basic WGNXZWJBcHA6WGNXZWJBcHA=&quot; headers.add(&quot;Authorization&quot;, httpbasic); //2、包括：grant_type、username、passowrd MultiValueMap&lt;String, String&gt; body = new LinkedMultiValueMap&lt;String, String&gt;(); body.add(&quot;grant_type&quot;,&quot;password&quot;); body.add(&quot;username&quot;,&quot;itcast&quot;); body.add(&quot;password&quot;,&quot;123&quot;); HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; multiValueMapHttpEntity = newHttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt;(body, headers);//指定 restTemplate当遇到400或401响应时候也不要抛出异常，也要正常返回值 restTemplate.setErrorHandler(new DefaultResponseErrorHandler()&#123; @Override public void handleError(ClientHttpResponse response) throws IOException &#123; //当响应的值为400或401时候也要正常响应，不要抛出异常 if(response.getRawStatusCode()!=400 &amp;&amp; response.getRawStatusCode()!=401)&#123; super.handleError(response); &#125; &#125; &#125;); //远程调用申请令牌 ResponseEntity&lt;Map&gt; exchange = restTemplate.exchange(authUrl, HttpMethod.POST,multiValueMapHttpEntity, Map.class); Map body1 = exchange.getBody(); System.out.println(body1); &#125; private String httpbasic(String clientId,String clientSecret)&#123; //将客户端id和客户端密码拼接，按“客户端id:客户端密码” String string = clientId+&quot;:&quot;+clientSecret; //进行base64编码 byte[] encode = Base64.encode(string.getBytes()); return &quot;Basic &quot;+new String(encode); &#125;&#125; 测试结果： 用户认证流程如下：网关进行身份校验流程：1、从cookie查询用户身份令牌是否存在，不存在则拒绝访问2、从http header查询jwt令牌是否存在，不存在则拒绝访问3 、从Redis查询user_token令牌是否过期，过期则拒绝访问1234567891011121314151617181920212223242526272829303132333435@Servicepublic class AuthService &#123; @Autowired StringRedisTemplate stringRedisTemplate; //查询身份令牌 public String getTokenFromCookie(HttpServletRequest request)&#123; Map&lt;String, String&gt; cookieMap = CookieUtil.readCookie(request, &quot;uid&quot;); String access_token = cookieMap.get(&quot;uid&quot;); if(StringUtils.isEmpty(access_token))&#123; return null; &#125; return access_token; &#125; //从header中查询jwt令牌 public String getJwtFromHeader(HttpServletRequest request)&#123; String authorization = request.getHeader(&quot;Authorization&quot;); if(StringUtils.isEmpty(authorization))&#123; //拒绝访问 return null; &#125; if(!authorization.startsWith(&quot;Bearer &quot;))&#123; //拒绝访问 return null; &#125; return authorization; &#125; //查询令牌的有效期 public long getExpire(String access_token) &#123; //token在redis中的key String key = &quot;user_token:&quot;+access_token; Long expire = stringRedisTemplate.getExpire(key); return expire; &#125;&#125; 定义LoginFilter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@Componentpublic class LoginFilter extends ZuulFilter &#123; private static final Logger LOGG = LoggerFactory.getLogger(LoginFilter.class); @Autowired AuthService authService; @Override public String filterType() &#123; //四种类型：pre、routing、post、error return &quot;pre&quot;; &#125; @Override public int filterOrder() &#123; return 0; &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() &#123; //上下文对象 RequestContext requestContext = RequestContext.getCurrentContext(); //请求对象 HttpServletRequest request = requestContext.getRequest(); //查询身份令牌 String access_token = authService.getTokenFromCookie(request); if(access_token == null)&#123;//拒绝访问 access_denied(); &#125; //从redis中校验身份令牌是否过期 long expire = authService.getExpire(access_token); if(expire&lt;=0)&#123; //拒绝访问 access_denied(); &#125; //查询jwt令牌 String jwt = authService.getJwtFromHeader(request); if(jwt == null)&#123; //拒绝访问 access_denied(); &#125; return null; &#125; //拒绝访问 private void access_denied()&#123; //上下文对象 RequestContext requestContext = RequestContext.getCurrentContext(); requestContext.setSendZuulResponse(false);//拒绝访问 //设置响应内容 ResponseResult responseResult =new ResponseResult(CommonCode.UNAUTHENTICATED); String responseResultString = JSON.toJSONString(responseResult); requestContext.setResponseBody(responseResultString); //设置状态码 requestContext.setResponseStatusCode(200); HttpServletResponse response = requestContext.getResponse(); response.setContentType(&quot;application/json;charset=utf‐8&quot;); &#125;&#125; 测试：Get请求：http://www.xuecheng.com/api/course/coursebase/get/4028e581617f945f01617f9dabc40000注意：这里通过网关请求了 course/coursebase/get地址，课程管理url根据自己的开发情况去配置，1、正常流程测试a、执行登录使之向cookie写入身份令牌uidPost请求：http://ucenter.xuecheng.com/openapi/auth/userlogin手动在postman添加header用户授权业务流程如下方法授权要完成的是资源服务根据jwt令牌完成对方法的授权，具体流程如下：1、生成Jwt令牌时在令牌中写入用户所拥有的权限我们给每个权限起个名字，例如某个用户拥有如下权限：course_find_list：课程查询course_pic_list：课程图片查询2、在资源服务方法上添加注解PreAuthorize，并指定此方法所需要的权限例如下边是课程管理接口方法的授权配置，它就表示要执行这个方法需要拥有course_find_list权限。12345678910//指定用户的权限，这里暂时硬编码 List&lt;String&gt; permissionList = new ArrayList&lt;&gt;(); permissionList.add(&quot;course_get_baseinfo&quot;); permissionList.add(&quot;course_find_pic&quot;); //将权限串中间以逗号分隔 String permissionString = StringUtils.join(permissionList.toArray(), &quot;,&quot;); //String user_permission_string = &quot;&quot;; UserJwt userDetails = new UserJwt(username, password, AuthorityUtils.commaSeparatedStringToAuthorityList(permissionString)); 重启认证服务工程，使用 postman完成登录，从redis中找到jwt令牌。使用jwt的测试程序查看 此令牌的内容资源服务添加授权控制 要想在资源服务使用方法授权，首先在资源服务配置授权控制 1）添加spring-cloud-starter-oauth2依赖。 2）拷贝授权配置类ResourceServerConfig。 3）在方法添加授权注解。 动态通过用户中心查询用户权限123456789101112131415//根据账号查询用户的信息，返回用户扩展信息public XcUserExt getUserExt(String username)&#123; XcUser xcUser = this.findXcUserByUsername(username); if(xcUser == null)&#123; return null; &#125; //根据用户id查询用户权限 String userId = xcUser.getId(); List&lt;XcMenu&gt; xcMenus = xcMenuMapper.selectPermissionByUserId(userId); XcUserExt xcUserExt = new XcUserExt(); BeanUtils.copyProperties(xcUser,xcUserExt); //用户的权限 xcUserExt.setPermissions(xcMenus); return xcUserExt;&#125; 修改认证服务的UserDetailServiceImpl，查询用户的权限，并拼接权限串，将原来硬编码权限代码删除，代码如下：1234567891011121314151617 //请求ucenter查询用户 XcUserExt userext = userClient.getUserext(username); if(userext == null)&#123; //返回NULL表示用户不存在，Spring Security会抛出异常 return null; &#125; //从数据库查询用户正确的密码，Spring Security会去比对输入密码的正确性 String password = userext.getPassword(); //指定用户的权限，这里暂时硬编码 List&lt;String&gt; permissionList = new ArrayList&lt;&gt;();// permissionList.add(&quot;course_get_baseinfo&quot;);// permissionList.add(&quot;course_find_pic&quot;); //取出用户权限 List&lt;XcMenu&gt; permissions = userext.getPermissions(); for(XcMenu xcMenu:permissions)&#123; permissionList.add(xcMenu.getCode()); &#125; 单页面应用校验教学管理中心是单页面应用，我们在路由变化时校验用户的身份，校验失败将跳转到登录页面。校验方法如下：1、如果成功从sessionStorage和cookie获取当前用户则继续访问2、如果sessionStorage中无当前用户，cookie中有当前用户则请求服务端获取jwt，如果成功则继续访问。3、以上两种情况都不满足则跳转到登录页面前端显示当前用户1、用户请求认证服务，登录成功。2、用户登录成功，认证服务向cookie写入身份令牌，向redis写入user_token（身份令牌及授权jwt授权令牌）3、客户端携带cookie中的身份令牌请求认证服务获取jwt令牌。4、客户端解析jwt令牌，并将解析的用户信息存储到sessionStorage中。jwt令牌中包括了用户的基本信息，客户端解析jwt令牌即可获取用户信息。5、客户端从sessionStorage中读取用户信息，并在页头显示。 sessionStorage ：sessionStorage 是H5的一个会话存储对象，在SessionStorage中保存的数据只在同一窗口或同一标签页中有效，在关闭窗口之后将会删除SessionStorage中的数据。seesionStorage的存储方式采用key/value的方式，可保存5M左右的数据（不同的浏览器会有区别）]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>内容管理系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CountDownLatch]]></title>
    <url>%2F2019%2F04%2F21%2Fdxc2%2F</url>
    <content type="text"><![CDATA[CountDownLatch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CountDownLatch是通过一个计数器来实现的，计数器的初始化值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就相应得减1。当计数器到达0时，表示所有的线程都已完成任务，然后在闭锁上等待的线程就可以恢复执行任务。”【1】举一个例子就是：CountDownLatch 就像裁判，三个方法运动员，运动员2,3都到达终点，但是运动员1摔了。裁判员只看到两位运动员到达终点不能宣布比赛结束，所以一直在等待阻塞。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public static void main(String[] args) &#123; ExecutorService executorService = Executors.newFixedThreadPool(3); final CountDownLatch cdl = new CountDownLatch(3); executorService.execute(new Runnable() &#123; public void run() &#123; try &#123; function1(); &#125; catch (Exception e) &#123; //异常处理 e.printStackTrace(); &#125; finally &#123; cdl.countDown(); &#125; // function1(); &#125; &#125;); executorService.execute(new Runnable() &#123; public void run() &#123; function2(); System.out.println(&quot;sum= &quot;+cdl.getCount()); cdl.countDown(); &#125; &#125;); executorService.execute(new Runnable() &#123; public void run() &#123; function3(); System.out.println(&quot;sum= &quot;+cdl.getCount()); cdl.countDown(); &#125; &#125;); try &#123; cdl.await(); //cdl.await(20,TimeUnit.SECONDS); System.out.println(&quot;三个执行线程结束&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); System.out.println(&quot;执行线程异常&quot;); &#125; finally &#123; executorService.shutdown(); System.out.println(&quot;执行线程关闭&quot;); &#125; &#125; private static void function1() &#123; int i = 10 / 0; System.out.println(&quot;方法一&quot;); &#125; private static void function2() &#123; System.out.println(&quot;方法二&quot;); &#125; private static void function3() &#123; System.out.println(&quot;方法三&quot;); &#125;&#125; 结果：方法抛出异常，但是没做异常处理导致不会执行线程关闭和其他线程，所有要在可能抛出异常的地方处理一下，避免阻塞]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Semaphore]]></title>
    <url>%2F2019%2F04%2F21%2Fdxc3%2F</url>
    <content type="text"><![CDATA[Semaphore&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Semaphore（信号量）是用来控制同时访问特定资源的线程数量，如果将给定许可数设置为1，就如同一个单例模式，即单个停车位，只有一辆车进，然后这辆车出来后，下一辆车才能进。就如同停车场系统一般，而Semaphore则相当于看守的人，用于控制总共允许停车的停车位的个数，而对于每辆车来说就如同一个线程，线程需要通过acquire()方法获取许可，而release()释放许可。如果许可数达到最大活动数，那么调用acquire()之后，便进入等待队列，等待已获得许可的线程释放许可，从而使得多线程能够合理的运行 1234567891011121314151617181920212223242526272829303132333435363738394041private static final Semaphore semaphore=new Semaphore(3,true); private static final ThreadPoolExecutor threadPool=new ThreadPoolExecutor(5,10,60,TimeUnit.SECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()); private static class InformationThread extends Thread&#123; private final String name; private final int age; public InformationThread(String name,int age) &#123; this.name=name; this.age=age; &#125; &lt;!-- more --&gt; public void run() &#123; try &#123; semaphore.acquire(); System.out.println(Thread.currentThread().getName()+&quot;:大家好，我是&quot;+name+&quot;我今年&quot;+age); Thread.sleep(1000); System.out.println(name+&quot;要准备释放许可证了&quot;); System.out.println(&quot;当前可使用的许可数为：&quot;+semaphore.availablePermits()); semaphore.release(); &#125; catch(InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; String[] name= &#123;&quot;李明&quot;,&quot;王五&quot;,&quot;张杰&quot;,&quot;王强&quot;,&quot;赵二&quot;,&quot;李四&quot;,&quot;张三&quot;&#125;; int[] age= &#123;26,27,33,45,19,23,41&#125;; for(int i=0;i&lt;7;i++) &#123; Thread t1=new InformationThread(name[i],age[i]); threadPool.execute(t1); &#125; &#125;&#125; 结果：因为我一开始限制了3，所以当第四个进来的时候，要等别人释放，他才可以得到许可证]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程笔试1]]></title>
    <url>%2F2019%2F04%2F21%2Fdxc4%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1 12345678910111213141516171819202122232425262728293031323334353637383940public class MyTest &#123; private ManyThreads2 many = new ManyThreads2(); public static void main(String[] args) &#123; // TODO Auto-generated method stub MyTest myTest = new MyTest(); myTest.test(); &#125; public void test() &#123; for (int i = 0; i &lt; 2; i++) &#123; new Thread(new Runnable() &#123; public void run() &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; 20; i++) &#123; many.inc(); &#125; &#125; &#125;).start(); new Thread(new Runnable() &#123; public void run() &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; 20; i++) &#123; many.dec(); &#125; &#125; &#125;).start(); &#125; &#125; class ManyThreads2 &#123; private int j = 0; public synchronized void inc() &#123; j++; System.out.println(Thread.currentThread().getName() + &quot;inc&quot; + j); &#125; public synchronized void dec() &#123; j--; System.out.println(Thread.currentThread().getName() + &quot;dec&quot; + j); &#125; &#125;&#125;]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程笔试3]]></title>
    <url>%2F2019%2F04%2F21%2Fdxc6%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//子线程循环 3 次，接着主线程循环 5 次，接着又回到子线程循环 3次，接着再回到主线程又循环 5 次，如此循环10次，试写出代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 public static void main(String[] args) &#123; final MyThread threads=new MyThread(); new Thread( new Runnable()&#123; public void run()&#123; for(int i=1;i&lt;=10;i++)&#123; threads.subThread(i); &#125; &#125; &#125; ).start(); new Thread(new Runnable()&#123; public void run()&#123; for(int i=1;i&lt;=10;i++)&#123; threads.mainThread(i); &#125; &#125; &#125;).start(); &#125; &#125; class MyThread&#123; boolean bShouldSub=true;//标志子线程方法是否被调用 public synchronized void subThread(int i)&#123; if(!bShouldSub)&#123;//若子线程没被调用，即主线程正在运行，所以等待 try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; for(int j=1;j&lt;=3;j++)&#123; System.out.println(&quot;sub thread :&quot;+i+&quot;,loop : &quot;+j); &#125; bShouldSub=false;//子线程运行完毕 this.notify();//唤醒其他线程，即主线程 &#125; public synchronized void mainThread(int i)&#123; if(bShouldSub)&#123;//若子线程正在被调用，所以等待 try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; for(int j=1;j&lt;=5;j++)&#123; System.out.println(&quot;main thread :&quot;+i+&quot;,loop : &quot;+j); &#125; bShouldSub=true;//主线程调用完毕 this.notify();//唤醒子线程 &#125;&#125;]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程笔试2]]></title>
    <url>%2F2019%2F04%2F21%2Fdxc5%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编写一个程序，开启 3 个线程，这三个线程的 ID 分别为 A、B、C，每个线程将自己的 ID 在屏幕上打印 10 遍，要求输出的结果必须按顺序显示。如：ABCABCABC 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public static void main(String[] args) &#123; final AlternateDemo ad1 = new AlternateDemo(); new Thread(new Runnable() &#123; public void run() &#123; for (int i = 0; i &lt; 5; i++) ad1.loopA(i); &#125; &#125;, &quot;A&quot;).start(); new Thread(new Runnable() &#123; public void run() &#123; for (int i = 0; i &lt; 5; i++) ad1.loopB(i); &#125; &#125;, &quot;B&quot;).start(); new Thread(new Runnable() &#123; public void run() &#123; for (int i = 0; i &lt;5; i++) ad1.loopC(i); &#125; &#125;, &quot;C&quot;).start(); &#125;&#125;class AlternateDemo &#123; //标志当前由哪一个线程输出，1代表A，2代表B，3代表C private int number = 1; Lock lock = new ReentrantLock(); //Condition的强大之处在于它可以为多个线程间建立不同的Condition Condition condition1 = lock.newCondition(); Condition condition2 = lock.newCondition(); Condition condition3 = lock.newCondition(); // loopNum:当前循环轮数 public void loopA(int loopNum) &#123; //上锁 lock.lock(); try &#123; while (number != 1) &#123; //等待 condition1.await(); &#125; System.out.println(Thread.currentThread().getName() + &quot;, currentLoopNum is &quot; + loopNum); number = 2; //唤醒 condition2.signal(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; //确保释放锁 lock.unlock(); &#125; &#125; public void loopB(int loopNum) &#123; lock.lock(); try &#123; while (number != 2) &#123; condition2.await(); &#125; System.out.println(Thread.currentThread().getName() + &quot;, currentLoopNum is &quot; + loopNum); number = 3; condition3.signal(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void loopC(int loopNum) &#123; lock.lock(); try &#123; while (number != 3) &#123; condition3.await(); &#125; System.out.println(Thread.currentThread().getName() + &quot;, currentLoopNum is &quot; + loopNum); number = 1; condition1.signal(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 结果： 第二种方法：利用原子类：123456789101112131415161718192021222324252627282930313233private static final int MAXN = 30; private AtomicInteger sycValue = new AtomicInteger(0); public void printABC()&#123; Thread threadA = new Thread(new ABCRunnable()); Thread threadB = new Thread(new ABCRunnable()); Thread threadC = new Thread(new ABCRunnable()); threadA.start(); threadB.start(); threadC.start(); &#125; public static void main(String[] args) &#123; Thread03 tt=new Thread03(); tt.printABC(); &#125; private class ABCRunnable implements Runnable&#123; @Override public void run() &#123; while (sycValue.get() &lt; MAXN)&#123; if (sycValue.get() % 3 == 0)&#123; System.out.print(&quot;A&quot;); sycValue.getAndIncrement(); &#125;else if (sycValue.get() % 3 == 1)&#123; System.out.print(&quot;B&quot;); sycValue.getAndIncrement(); &#125;else if (sycValue.get() % 3 == 2) &#123; System.out.print(&quot;C&quot;); sycValue.getAndIncrement(); &#125; &#125; &#125; &#125;&#125; 第三种方法：使用同步方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 private char currThreadName = &apos;A&apos;; public static void main(String[] args) &#123; Thread04 thread04=new Thread04(); thread04.printABC(); &#125; public void printABC() &#123; Thread threadA = new Thread(new PrintATask()); Thread threadB = new Thread(new PrintBTask()); Thread threadC = new Thread(new PrintCTask()); threadA.start(); threadB.start(); threadC.start(); &#125; private synchronized void printA() &#123; try &#123; while (currThreadName != &apos;A&apos;) &#123; wait(); &#125; System.out.print(&quot;A&quot;); currThreadName = &apos;B&apos;; notifyAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); notifyAll(); &#125; &#125; private synchronized void printB() &#123; try &#123; while (currThreadName != &apos;B&apos;) &#123; wait(); &#125; System.out.print(&quot;B&quot;); currThreadName = &apos;C&apos;; notifyAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); notifyAll(); &#125; &#125; private synchronized void printC() &#123; try &#123; while (currThreadName != &apos;C&apos;) &#123; wait(); &#125; System.out.print(&quot;C&quot;); currThreadName = &apos;A&apos;; notifyAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); notifyAll(); &#125; &#125; private class PrintATask implements Runnable &#123; public void run() &#123; for (int i = 0; i &lt; 10; ++i) &#123; printA(); &#125; &#125; &#125; private class PrintBTask implements Runnable &#123; public void run() &#123; for (int i = 0; i &lt; 10; ++i) &#123; printB(); &#125; &#125; &#125; private class PrintCTask implements Runnable &#123; public void run() &#123; for (int i = 0; i &lt; 10; ++i) &#123; printC(); &#125; &#125; &#125;&#125; 4.使用Semaphore，这个方法我不太理解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//semaphore是没有所有者的说法, 可以跨线程释放和获取.public class Thread06 &#123; private static Semaphore A = new Semaphore(1); private static Semaphore B = new Semaphore(1); private static Semaphore C = new Semaphore(1); static class ThreadA extends Thread &#123; public void run() &#123; try &#123; for (int i = 0; i &lt; 10; i++) &#123; A.acquire(); System.out.print(&quot;A&quot;); B.release(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; static class ThreadB extends Thread &#123; public void run() &#123; try &#123; for (int i = 0; i &lt; 10; i++) &#123; B.acquire(); System.out.print(&quot;B&quot;); C.release(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; static class ThreadC extends Thread &#123; public void run() &#123; try &#123; for (int i = 0; i &lt; 10; i++) &#123; C.acquire(); System.out.println(&quot;C&quot;); A.release(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; B.acquire(); C.acquire();// 开始只有A可以获取, BC都不可以获取, 保证了A最先执行 //如果许可数达到最大活动数，那么调用acquire()之后，便进入等待队列，等待已获得许可的线程释放许可，从而使得多线程能够合理的运行 new ThreadB().start(); new ThreadA().start(); new ThreadC().start(); &#125;&#125;/*Semaphore(int permits):构造方法，创建具有给定许可数的计数信号量并设置为非公平信号量。Semaphore(int permits,boolean fair):构造方法，当fair等于true时，创建具有给定许可数的计数信号量并设置为公平信号量。void acquire():从此信号量获取一个许可前线程将一直阻塞。相当于一辆车占了一个车位void acquire(int n):从此信号量获取给定数目许可，在提供这些许可前一直将线程阻塞。比如n=2，就相当于一辆车占了两个车位。void release():释放一个许可，将其返回给信号量。就如同车开走返回一个车位。void release(int n):释放n个许可。int availablePermits()：当前可用的许可数。*/最好是改成private static Semaphore A = new Semaphore(1); private static Semaphore B = new Semaphore(0); private static Semaphore C = new Semaphore(0)；注释掉// B.acquire(); C.acquire(); 这样比较好理解，也能实现哦]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CyclicBarrier]]></title>
    <url>%2F2019%2F04%2F16%2Fdxc7%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。例如，用一个Excel保存了用户所有银行流水，每个Sheet保存一个账户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的日均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水 12345678910111213141516171819202122232425262728293031323334353637383940414243444546publicclass BankWaterService implements Runnable &#123;/*** 创建4个屏障，处理完之后执行当前类的run方法*/private CyclicBarrier c = new CyclicBarrier(4, this);/*** 假设只有4个sheet，所以只启动4个线程*/private Executor executor = Executors.newFixedThreadPool(4);/*** 保存每个sheet计算出的银流结果*/private ConcurrentHashMap&lt;String, Integer&gt;sheetBankWaterCount = new ConcurrentHashMap&lt;String, Integer&gt;(); privatevoid count() &#123; for (inti = 0; i&lt; 4; i++) &#123; executor.execute(new Runnable() &#123; publicvoid run() &#123; // 计算当前sheet的银流数据，计算代码省略 sheetBankWaterCount.put(Thread.currentThread().getName(), 1);// 银流计算完成，插入一个屏障 try &#123; c.await(); &#125; catch (InterruptedException |BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;&#125;); &#125;&#125;publicvoid run() &#123; intresult = 0;// 汇总每个sheet计算出的结果 for (Entry&lt;String, Integer&gt;sheet : sheetBankWaterCount.entrySet()) &#123; result += sheet.getValue();&#125;// 将结果输出 sheetBankWaterCount.put(&quot;result&quot;, result); System.out.println(result);&#125;publicstaticvoid main(String[] args) &#123; BankWaterService bankWaterCount = new BankWaterService(); bankWaterCount.count();&#125;&#125; 输出结果是：4 参考书籍：并发编程的艺术]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程阻塞队列]]></title>
    <url>%2F2019%2F04%2F15%2Fdxc1%2F</url>
    <content type="text"><![CDATA[1.阻塞队列和线程池实现消费生产模式如果是无界阻塞队列，队列不可能会出现满的情况，所以使用put或offer方法永远不会被阻塞，而且使用offer方法时，该方法永远返回true消费者1234567891011121314151617181920212223242526272829303132333435public class BlockingQueueConsumer implements Runnable&#123; private BlockingQueue&lt;String&gt; queue; private static final int DEFAULT_RANGE_FOR_SLEEP = 1000; public BlockingQueueConsumer(BlockingQueue&lt;String&gt; queue)&#123; this.queue=queue; &#125; public void run() &#123; System.out.println(&quot;启动消费者线程&quot;); Random random=new Random(); boolean isRunning=true; try &#123; while(true)&#123; System.out.println(&quot;正在从队列获取数据&quot;); String data = queue.poll(2, TimeUnit.SECONDS); //超过2S没数据，就失败，移除并返问队列头部的元素，如果队列为空，则返回null if(data!=null)&#123; System.out.println(&quot;拿到数据&quot;+data); System.out.println(&quot;正在消费数据&quot;+data); Thread.sleep(random.nextInt(DEFAULT_RANGE_FOR_SLEEP)); &#125;else&#123; //超过2S还没数据，认为所有生产线程已经推出了，退出消费线程 isRunning=false; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); Thread.currentThread().interrupt(); &#125;finally&#123; System.out.println(&quot;退出消费者线程&quot;); &#125; &#125;&#125; 生产者123456789101112131415161718192021222324252627282930313233343536public class BlockingQueueProducer implements Runnable&#123; private volatile boolean isRunning=true;//是否在运行标志 private BlockingQueue queque; private static AtomicInteger count=new AtomicInteger(); private static final int DEFAULT_RANGE_FOR_SLEEP = 1000; public BlockingQueueProducer(BlockingQueue queue)&#123; this.queque=queue; &#125; public void run() &#123; String data=null; Random random=new Random(); System.out.println(&quot;启动生产者线程&quot;); try &#123; while(isRunning)&#123; System.out.println(&quot;正在生产数据&quot;); Thread.sleep(random.nextInt(DEFAULT_RANGE_FOR_SLEEP)); data=&quot;data:&quot;+count.incrementAndGet();//以原子方式加1 System.out.println(&quot;将数据：&quot; + data + &quot;放入队列...&quot;); if(!queque.offer(data, 2, TimeUnit.SECONDS))&#123; //设定的等待时间为2s，如果超过2s还没加进去返回true；添加一个元素并返回true，如果队列已满，则返回false System.out.println(&quot;存入数据失败&quot;+data); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); Thread.currentThread().interrupt(); &#125;finally&#123; System.out.println(&quot;退出生产者线程&quot;); &#125; &#125; public void stop()&#123; isRunning=false; &#125;&#125; 主方法12345678910111213141516171819202122232425 public static void main(String[] args) throws Exception &#123; // 声明一个容量为10的缓存队列 BlockingQueue&lt;String&gt; queue = new LinkedBlockingQueue&lt;String&gt;(10); //new了三个生产者和一个消费者 BlockingQueueProducer producer1 = new BlockingQueueProducer(queue); BlockingQueueProducer producer2 = new BlockingQueueProducer(queue); BlockingQueueProducer producer3 = new BlockingQueueProducer(queue); BlockingQueueConsumer consumer = new BlockingQueueConsumer(queue); // 借助Executors ExecutorService service = Executors.newCachedThreadPool(); // 启动线程 service.execute(producer1); service.execute(producer2); service.execute(producer3); service.execute(consumer); // 执行10s Thread.sleep(5 * 1000); producer1.stop(); producer2.stop(); producer3.stop(); Thread.sleep(2000); // 退出Executor service.shutdown(); &#125;&#125; 结果：解释下：声明了容量为10的阻塞队列，然后先启动生产者线程，初始化一个volatile变量isRunning，使得其他线程刷到最新的数据，初始化了一个原子类Integer，假设第一个线程先拿到线程，然后睡眠了一会，给消费者拿到线程然后启动线程，但是还没获取线程就给另一个生产者线程抢到了cpu，他正在生产数据，但是还没正式原子方式加1…如果消费者移除了队列头元素，则立即返回头元素；否则在到达超时2s时，返回null，认为所有生产线程退出了，就退出消费线程。生产者就把原子类自增的值加到队列尾巴，如果超过2s没加就返回true，不会阻塞 2.死锁例子1234567891011121314151617181920212223242526272829303132public class DeadLockDemo &#123; private static String A = &quot;A&quot;; private static String B = &quot;B&quot;; public static void main(String[] args) &#123; new DeadLockDemo().deadLock(); &#125; private void deadLock() &#123; Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (A) &#123; try &#123; Thread.currentThread().sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (B) &#123; System.out.println(&quot;1&quot;); &#125; &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (B) &#123; synchronized (A) &#123; System.out.println(&quot;2&quot;); &#125;&#125; &#125; &#125;); t1.start(); t2.start(); &#125;&#125;]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库题（1）]]></title>
    <url>%2F2019%2F04%2F15%2Fmysql1%2F</url>
    <content type="text"><![CDATA[1.求前三名的名字和分数以及其他人分数的总和结果： 123456select * from (select s.name,s.score FROM score s ORDER BYscore desc limit 3)bUNION allselect &apos;其他&apos;,sum(score) from score ss where ss.name not in (select b.name from(SELECT `NAME` FROM score s ORDER BY score DESC LIMIT 3 )b) 解释下：UNION 操作符用于合并两个或多个 SELECT 语句的结果集。请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。 union和union all 的区别。union会过滤掉两个结果集中重复的行，而union all不会过滤掉重复行 这里有2个坑：union 和 order by 不能共存的，会报错123select s.name,s.score FROM score s ORDER BYscore desc limit 3UNION all 要用select * from (…)b 包起来，再起个别名 还有个坑：这里mysql的这个版本是不支持in里面的语句使用limit解题用的第二种sql语句的完整执行顺序1、from子句组装来自不同数据源的数据； 2、where子句基于指定的条件对记录行进行筛选；3、group by子句将数据划分为多个分组；4、使用聚集函数进行计算；5、使用having子句筛选分组；6、计算所有的表达式；7、使用order by对结果集进行排序。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库题（2）]]></title>
    <url>%2F2019%2F04%2F15%2Fmysql2%2F</url>
    <content type="text"><![CDATA[1.学生表student 字段（id,name），学生科目成绩表stu_score字段（stu_id,subject,score）查询出所有科目分数都大于80分的所有学生的姓名与分数有两种方法:1、123456select name from stugroup by namehaving name not in (select name from stuwhere score &lt;80) 按照名字分组，然后找出分数小于80的人，过滤名字不在该里面的 2、123select name from test.stugroup by namehaving min(score)&gt;=80 按照名字分组，过滤having最小的分数&gt;=80的人]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序]]></title>
    <url>%2F2019%2F04%2F15%2Fpx%2F</url>
    <content type="text"><![CDATA[1.冒泡排序算法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比较两个相邻的元素，将值大的元素交换至右端每进行一趟排序，就会少比较一次12345678910111213for (int i = 0; i &lt; arr.length; i++) &#123;// 外层循环控制排序趟数 for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123;// 内层循环控制每一趟排序多少次 if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;解释：第一个for循环i&lt;arr.length，就是外层循环的次数。第二次for循环j&lt;arr.length-1-i就是两两比较，到倒数第二数和最后一个比较就没了，所以要-1，-i是因为第一次是i=0开始要比较到倒数第二个(跟后面的数比较)，然后得出最大的在最右边，所以每次循环最大都在右边，所以要-i 2.选择排序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一趟循环比较时，min用于存放较小元素的数组下标，这样当前批次比较完毕最终存放的就是此趟内最小的元素的下标，避免每次遇到较小元素都要进行交换。123456789101112131415161718public static void selectSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int min = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; min = j; &#125; &#125; //进行交换，如果min发生变化，则进行交换 if (min != i) &#123; swap(arr,min,i); &#125; &#125;&#125;解释：第一个for循环i&lt;arr.length-1，因为每次比较小的都在左边，所以最大的肯定在最右边，只用到倒数第二个，arr.length-1就好了。假设最小的是min，是第一个元素，然后第二个循环就是遍历min的后面所有元素跟他比较，所以要j&lt;arr.length，如果小于就覆盖Min最后如果min变化了就交换！！ 3.快速排序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在要排的数（比如数组A）中选择一个中心值key（比如A[0]），通过一趟排序将数组A分成两部分，其中以key为中心，key右边都比key大，key左边的都key小，然后对这两部分分别重复这个过程，直到整个有序。123456789101112131415161718192021222324public static void kuaisu(int[] arr, int low, int high) &#123; if (low &lt; high) &#123; int i = low; int j = high; int temp = arr[low]; while (i &lt; j) &#123; while (temp &lt;= arr[j] &amp;&amp; i &lt; j) &#123; j--; &#125; while (temp &gt;= arr[i] &amp;&amp; i &lt; j) &#123; i++; &#125; if (i &lt; j) &#123; int t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125; &#125; arr[low] = arr[i];//需要注意的 两个互换 arr[i] = temp; kuaisu(arr, low, i - 1); kuaisu(arr, i + 1, high); &#125; &#125; 4.二分法（有序数组）1234567891011121314151617public static int erfen(int [] a,int idx)&#123; int min = 0; int max = a.length-1; while(min &lt;= max) &#123; int middle = (min + max)/2; if(a[middle] == idx) &#123; return middle; &#125; if(idx &gt; a[middle]) &#123; min = middle+1; &#125; else &#123; max = middle - 1; &#125; &#125; return -1; &#125;]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>时间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2019%2F04%2F15%2Fsjms%2F</url>
    <content type="text"><![CDATA[1.工厂模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在父类中定义创建对象的一个接口，让子类决定实例化哪个类简单工厂：1234567891011121314151617181920212223242526272829303132public interface Shape &#123; void draw();&#125;public class Circle implements Shape&#123; public void draw() &#123; System.out.println(&quot;drwo circle&quot;); &#125;&#125;public class Rectangle implements Shape&#123; public void draw() &#123; System.out.println(&quot;drwo Rectangle&quot;); &#125;&#125;public class ShapeFactory &#123; public static Shape getshape(String type)&#123; if(type==null)&#123; return null; &#125; if(type.equals(&quot;circle&quot;))&#123; return new Circle(); &#125;else if(type.equals(&quot;Rectangle&quot;))&#123; return new Rectangle(); &#125; return null; &#125; public static void main(String[] args) &#123; ShapeFactory.getshape(&quot;circle&quot;).draw(); &#125;&#125; 抽象工厂模式：是生产一整套有产品的（至少要生产两个产品)，这些产品必须相互是有关系或有依赖的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public interface Gun &#123; public void shooting(); //手枪&#125;public interface Bullet &#123; public void load();//子弹&#125;public class AK implements Gun&#123; public void shooting() &#123; System.out.println(&quot;shooting with Ak&quot;); &#125;&#125;class M4A1 implements Gun&#123; public void shooting() &#123; System.out.println(&quot;shooting with m4a1&quot;); &#125;&#125;public class AK_bullet implements Bullet&#123; public void load() &#123; System.out.println(&quot;给ak加子弹&quot;); &#125;&#125;class M4A1_bullet implements Bullet&#123; public void load() &#123; System.out.println(&quot;给m4a1加子弹&quot;); &#125;&#125;public interface Factory &#123; public Gun produceGun(); public Bullet produceBullet();&#125;public class Ak_factory implements Factory&#123; public Gun produceGun() &#123; return new AK(); &#125; public Bullet produceBullet() &#123; return new AK_bullet(); &#125; &#125; main() &#123; Factory factory=new Ak_factory(); Bullet bullet = factory.produceBullet(); bullet.load(); Gun gun = factory.produceGun(); gun.shooting(); //给ak加子弹 shooting with Ak &#125; 2、建造者模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使得相同的创建过程可以创建不同的产品对象。建造者模式主要包含四个角色: Product（产品角色）：一个具体的产品对象。 Builder（抽象建造者）：创建一个Product对象的各个部件指定的抽象接口。ConcreteBuilder（具体建造者）：实现抽象接口，构建和装配各个部件。 Director（指挥者）：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象 KFC套餐，套餐是复杂对象，一般包含主食（汉堡，鸡肉卷）和饮料（果汁）等，不同的套餐有不同的组成部分，而服务员可以根据顾客的要求，一步一步的组装，构造成一份完整的套餐123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Meal &#123; private String food; ...get/set/tostring方法&#125;//具体的产品public abstract class MealBuilder &#123;public Meal getMeal() &#123; return meal; &#125; //抽象建造者 Meal meal=new Meal(); public abstract void buidFood(); public abstract void buidDrink();&#125;public class MealA extends MealBuilder&#123; public void buidFood() &#123; meal.setFood(&quot;汉堡&quot;); &#125; public void buidDrink() &#123; meal.setDrink(&quot;薯条&quot;); &#125;//套餐A 具体建造者：实现抽象接口，构建和装配各个部件&#125;//构建一个使用builder接口的对象，用于创建复杂的对象，作用：隔离客户与对象的生产过程，负责控制产品对象的生产过程public class KFCWaiter &#123; //指挥者 private MealBuilder mealBuilder; public KFCWaiter(MealBuilder mealBuilder)&#123; this.mealBuilder=mealBuilder; &#125; public Meal construct()&#123; mealBuilder.buidFood();//准备食物 mealBuilder.buidDrink();//准备饮料 return mealBuilder.getMeal(); &#125;//准备完毕，返回给客户&#125;public static void main(String[] args) &#123; MealA mealA=new MealA();//套餐A //这里传了抽象类的子类↓↓↓ KFCWaiter waiter=new KFCWaiter(mealA);//准备套餐A的服务员 waiter.construct();//获得套餐 System.out.println(mealA.getMeal()); &#125;输出结果：Meal [food=汉堡, drink=薯条] 3、适配器模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;读卡器是作为内存卡和笔记本之间的适配器。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。简单点理解就是平常所见的转接头，转换器之类的存在。 1、类适配器模式 ：通过继承来实现123456789101112131415161718192021222324public interface Ps2 &#123; void isPs2(); //ps2接口 &#125;public interface Usb &#123; void isUsb(); //usb接口 &#125; public class Usber implements Usb &#123; public void isUsb() &#123; System.out.println(&quot;USB口&quot;); &#125;//usb接口实现类 &#125; public class Adapter extends Usber implements Ps2 &#123; public void isPs2() &#123; isUsb(); &#125;//适配器 &#125; main()&#123; Ps2 p=new Adapter(); p.isPs2(); //输出：usb口 &#125; 2、对象适配器模式:通过组合来实现适配器功能1234567891011121314ps2,usb接口及其实现同上，不同的是适配器的实现方式public class Adapter implements Ps2 &#123; private Usb usb; public Adapter(Usb usb)&#123; this.usb = usb; &#125; public void isPs2() &#123; usb.isUsb(); &#125; &#125; public static void main(String[] args) &#123; Ps2 p = new Adapter(new Usber()); p.isPs2(); &#125; 3、接口适配器模式:通过抽象类来实现适配当存在这样一个接口，其中定义了N多的方法，而我们现在却只想使用其中的一个到几个方法。这时我们可以使用一个抽象类作为中间件，即适配器，用这个抽象类实现接口，而在抽象类中所有的方法都进行置空，那么我们在创建抽象类的继承类，而且重写我们需要使用的那几个方法即可。123456789101112131415161718192021222324public interface A &#123; void a(); void b(); void c(); void d();&#125;//目标接口public abstract class Adapter implements A&#123; public void a()&#123;&#125;; public void b()&#123;&#125;; public void c()&#123;&#125;; public void d()&#123;&#125;;&#125;//适配器public class Ashili extends Adapter&#123; public void a() &#123; System.out.println(&quot;aa&quot;); &#125; public void b() &#123; System.out.println(&quot;bb&quot;); &#125;//选择实现想要实现的方法 public static void main(String[] args) &#123; A a=new Ashili(); a.b(); &#125;&#125; 4、装饰器模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对已经存在的某些类进行装饰，以此来扩展一些功能123456789101112131415161718192021222324252627282930//基础接口public interface Component &#123; public void biu();&#125;//具体实现类public class ConcretComponent implements Component &#123; public void biu() &#123; System.out.println(&quot;biubiubiu&quot;); &#125;&#125;//装饰类:在构造函数传新添加的对象public abstract class Decorator implements Component &#123; public Component component; public Decorator(Component component) &#123; this.component = component; &#125; public void biu() &#123; this.component.biu(); &#125;&#125;//具体装饰类public class ConcreteDecorator extends Decorator &#123; public ConcreteDecorator(Component component) &#123; super(component); &#125;//这里可以调用添加的对象的方法，我没实现而已 public void biu() &#123; System.out.println(&quot;ready?go!&quot;); this.component.biu(); &#125;&#125; 5、代理模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过代理对象访问目标对象.简单的来说就是中介。静态代理 （运行之前，代理类.class文件就已经被创建）1234567891011121314151617181920212223242526272829public interface BuyHouse&#123; void buyhouse();&#125;public class BuyHouseImpl implements BuyHouse&#123; public void buyhouse() &#123; syso(&quot;我要买房&quot;); &#125;&#125;public class BuyHouseImplProxy implements BuyHouse&#123; private BuyHouse buyhouse; public BuyHouseImplProxy(final BuyHouse buyhouse)&#123; this.buyhouse=buyhouse; &#125; public void buyhouse() &#123; syso(&quot;买房前的准备&quot;); buyhouse.buyhouse(); syso(&quot;买房后的装修&quot;); &#125;&#125; main()&#123; BuyHouse bh=new BuyHouseImpl(); BuyHouseImplProxy bhproxy=new BuyHouseImplProxy(bh); bhproxy.buyhouse(); &#125; 动态代理如下： 6、策略模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我清楚知道自己身上有几把武器（策略），我会根据不同的情况使用不同的武器（根据情况，切换策略1234567891011121314151617181920212223242526272829public interface Weapon &#123; public void gun();//抽象策略&#125;public class FirstGun implements Weapon &#123; public void gun() &#123; System.out.println(&quot;使用AWM狙击步枪。&quot;); &#125;//具体策略&#125;public class SecondGun implements Weapon &#123; public void gun() &#123; System.out.println(&quot;使用S12K霰弹枪。&quot;); &#125;&#125;public class Context &#123; Weapon weapon;//环境类 public Context(Weapon weapon) &#123; //构造函数 super(); this.weapon = weapon; &#125; public Weapon getWeapon() &#123; //get方法 return weapon; &#125; public void setWeapon(Weapon weapon) &#123; //set方法 this.weapon = weapon; &#125; public void gun() &#123; weapon.gun(); &#125;&#125; 7、模板模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现 创建一个抽象类，它的模板方法被设置为 final。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public abstract class DodishTemplate &#123; /** * 具体的整个过程 */ protected void dodish()&#123; this.preparation(); this.doing(); this.carriedDishes(); &#125; /** * 备料 */ public abstract void preparation(); /** * 做菜 */ public abstract void doing(); /** * 上菜 */ public abstract void carriedDishes ();&#125;/** * 西红柿炒蛋 * @author aries */public class EggsWithTomato extends DodishTemplate&#123; public void preparation() &#123; System.out.println(&quot;洗并切西红柿，打鸡蛋。&quot;); &#125; public void doing() &#123; System.out.println(&quot;鸡蛋倒入锅里，然后倒入西红柿一起炒。&quot;); &#125; public void carriedDishes() &#123; System.out.println(&quot;将炒好的西红寺鸡蛋装入碟子里，端给客人吃。&quot;); &#125;&#125; public static void main(String[] args) &#123; DodishTemplate eggsWithTomato = new EggsWithTomato(); eggsWithTomato.dodish(); System.out.println(&quot;-----------------------------&quot;); DodishTemplate bouilli = new Bouilli(); bouilli.dodish(); &#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库题（3）]]></title>
    <url>%2F2019%2F04%2F15%2Fmysql3%2F</url>
    <content type="text"><![CDATA[1.查询一服（serverId=1）最近3天中，新增的付费玩家统计，按玩家分组，结果格式玩家id 充值总次数 充值总金额 充值总元宝结果： 1234567891011121314SELECT COUNT( playerId ) &apos;充值总次数&apos;, serverId &apos;服Id&apos;, SUM( moneyNum ) &apos;充值总金额&apos;, SUM( goldNum ) &apos;总元宝&apos; FROM PayLog WHERE DATE_SUB( now( ), INTERVAL 3 DAY ) &lt;= FROM_UNIXTIME( payDate ) #比较的是时间时分秒 //TO_DAYS(now())- TO_DAYS(FROM_UNIXTIME(payDate))&lt;=3 这种方法比较天数 //DATE_SUB( CURDATE( ), INTERVAL 3 DAY ) &lt;= date( FROM_UNIXTIME( payDate ) ) 这种得到年月日比较 AND serverId = 1 #一服 GROUP BY playerId #按玩家分组 解释一下（上面方法采取的是取三天前的时间数据，和三天内的数据时间比较，如果小于就说明是三天内，因为我们在这里存的是时间戳所以要转为时间数据再比较）select DATE_SUB( CURDATE( ), INTERVAL 3 DAY) 得到年月日：2.按服务器，日期分组统计，每服务器每天充值总金额超过1万的统计，结果格式日期，服务器，充值总人数，充值总次数，充值总金额，充值中元宝1234567891011121314SELECT ( SELECT FROM_UNIXTIME( payDate, &apos;%Y-%m-%d&apos; ) ) &apos;时间&apos;, serverId &apos;服务器&apos;, SUM( moneyNum ) &apos;总金额&apos;, SUM( goldNum ) &apos;总元宝&apos;, COUNT( orderId ) &apos;总充值次数&apos;, COUNT( DISTINCT playerId ) &apos;总人数&apos; FROM paylog GROUP BY serverId, ( SELECT FROM_UNIXTIME( payDate, &apos;%Y-%m-%d&apos; ) ) HAVING SUM( moneyNum ) &gt;= 10000 3.1. 查询2019-04-20充值最高前2的账号 //结果143–437767931 ,144-784215429123456789101112SELECT playerId &apos;用户Id&apos;, zhanghao &apos;账号&apos;, moneyNum &apos;金额&apos;, ( SELECT FROM_UNIXTIME( payDate, &apos;%Y-%m-%d&apos; ) ) &apos;时间&apos; FROM paylog WHERE ( SELECT FROM_UNIXTIME( payDate, &apos;%Y-%m-%d&apos; ) ) = &apos;2019-04-20&apos; ORDER BY moneyNum DESC LIMIT 2 4. 写出各区间充值统计信息，结果如下： 1-10000 ：1人 —-2 10000-20000:2人 —-2 20000以上：3人这样 —4 123456SELECT SUM( CASE WHEN moneyNum BETWEEN 1 AND 10000 THEN 1 ELSE 0 END ) AS &apos;1-10000之间的&apos;, SUM( CASE WHEN moneyNum BETWEEN 10001 AND 20000 THEN 1 ELSE 0 END ) AS &apos;10000-2万之间的&apos;, SUM( CASE WHEN moneyNum &gt; 20000 THEN 1 ELSE 0 END ) AS &apos;2万以上的&apos; FROM paylog 12345678910--简单case函数case sex when &apos;1&apos; then &apos;男&apos; when &apos;2&apos; then &apos;女’ else &apos;其他&apos; end--case搜索函数case when sex = &apos;1&apos; then &apos;男&apos; when sex = &apos;2&apos; then &apos;女&apos; else &apos;其他&apos; end #case的基本用法 SELECT UNIX_TIMESTAMP(CURRENT_TIMESTAMP);//unix_timestamp() 得到当前时间戳 1560348971SELECT DATE_SUB(NOW(),INTERVAL 3 DAY) AS OrderPayDate ；//当前时间的三天前(不是毫秒) 2019-06-09 22:15:23FROM_UNIXTIME()函数语法：FROM_UNIXTIME(unix_timestamp,format)参数unix_timestamp 时间戳 可以用数据库里的存储时间数据的字段SELECT FROM_UNIXTIME( 1560348400 ,”%Y-%m-%d”) //2019-06-12如果format不写默认到时分秒2019-06-12 22:06:40 =’%Y-%m-%d %H:%i:%S’DATE_SUB() 函数从日期减去指定的时间间隔。语法：DATE_SUB(date,INTERVAL expr type)type 参数可以是下列值：SECOND，MINUTE,HOUR,DAY,WEEK,MONTHSELECT CURRENT_TIMESTAMP//获取当前时间 使用SELECT now()也行 2019-06-12 22:35:33SELECT CURDATE()//获得当前日期 2019-06-12SELECT TO_DAYS(now())//to_days函数：返回从0000年（公元1年）至当前日期的总天数SELECT DATE_FORMAT(now(),’%Y-%m’)//DATE_FORMAT() 函数用于以不同的格式显示日期/时间数据 2019-06 补充几个：select date_sub(now(), interval 1 hour);//前一个小时 2019-06-12 22:14:44select date_add(now(),interval -30 minute)//半个钟前 2019-06-12 22:45:28select date_sub(curdate(),interval 1 day);//取得前一天（年月日），注意这里第一个参数必须是年月日，不能是now() 2019-06-11 假如有个时间time= ‘2019-05-05 07:15:30’ select year(‘2019-05-05 07:15:30’);//选取日期的年份 2019select date(‘2019-05-05 07:15:30’);//选取日期的日期 2019-05-05 对日期进行计算（为日期增加一个时间间隔）date_add()，以增加为例select date_add(now(), interval 1 day); //2019-06-13 23:34:00 当前日期加一天select date_add(now(), interval 1 hour); //当前日期加一小时 类似的还有 1 minute ,second,week,month 今天 1select * from 表名 where to_days(时间字段名) = to_days(now()); 昨天 1SELECT * FROM 表名 WHERE TO_DAYS( NOW( ) ) - TO_DAYS( 时间字段名) &lt;= 1 7天 1SELECT * FROM 表名 where DATE_SUB(CURDATE(), INTERVAL 7 DAY) &lt;= date(时间字段名) 近30天 1SELECT * FROM 表名 where DATE_SUB(CURDATE(), INTERVAL 30 DAY) &lt;= date(时间字段名) 本月 1SELECT * FROM 表名 WHERE DATE_FORMAT( 时间字段名, &apos;%Y%m&apos; ) = DATE_FORMAT( CURDATE( ) , &apos;%Y%m&apos; ) 上一月 1SELECT * FROM 表名 WHERE PERIOD_DIFF( date_format( now( ) , &apos;%Y%m&apos; ) , date_format( 时间字段名, &apos;%Y%m&apos; ) ) =1 //PERIOD_DIFF(P1,P2) 返回周期P1和P2之间的月数]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库优化]]></title>
    <url>%2F2019%2F04%2F15%2Fsjkyh%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定位：查找，定位慢查询，并优化1.优化手段：2.创建索引：创建合适的索引，我们就可以现在索引中查询，查询到以后直接找对应的记录。 1234567891011121314151617181920212223id: 表示查询中select操作表的顺序,按顺序从大到依次执行select_type :表示选择的类型,常见可选值有: SIMPLE(简单的), PRIMARY(最外层) ，SUBQUERY(子查询中的第一个select查询)type :该属性表示访问类型,有很多种访问类型。最常见的其中包括以下几种: ALL(全表扫描), index(索引扫描),range(范围扫描),ref (非唯一索引扫描),eq_ref(唯一索引扫描,),(const)常数引用, 访问速度依次由慢到快。1.eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键 或 唯一索引扫描2.const：表示通过索引一次就找到了，const用于比较primary key 或者 unique索引。因为只需匹配一行数据3.ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质是也是一种索引访问possible_keys :该查询语句,可能走的索引,(如某些字段上索引的名字)这里提供的只是参考,而不是实际走的索引,也就导致会有possible_Keys不为null,key为空的现象。key : 显示MySQL实际使用的索引,其中就包括主键索引(PRIMARY),或者自建索引的名字。key_len : 表示索引所使用的字节数，ref :连接匹配条件,如果走主键索引的话,该值为: const, 全表扫描的话,为null值rows :扫描行数,也就是说，需要扫描多少行,采能获取目标行数,一般情况下会大于返回行数。通常情况下,rows越小,效率越高, 大部分SQL优化，都是在减少这个值的大小。Extra:这个属性非常重要,该属性中包括执行SQL时的真实情况信息,如上面所属,使用到的是&quot;using where&quot;，表示使用where筛选得到的值,常用的有: &quot;Using temporary&quot;: 使用临时表 &quot;using filesort&quot;: 使用文件排序 3.分表：当一张表的数据比较多或者一张表的某些字段的值比较多并且很少使用，采用水平分表和垂直分表来优化，分表分为垂直拆分和水平拆分： 1)垂直拆分：按照业务将表进行分类，把原来的一个很多字段的表拆分多个表。你可以把不常用的字段单独放到一个表中，也可以把大字段独立放一个表中，或者把关联密切的字段放一个表中。将不同业务的字段/表进行独立，拆到不同的数据库 2)水平拆分：水平拆分：垂直拆分是把不同的表拆到不同的数据库中；水平把原来一个表拆分成多个表，每个表的结构都一样，解决单表数据量大的问题。指纯粹的按照某种数据规则/格式进行拆分。例如 按照数据唯一ID的哈希散列拆分、按照数据的日期拆分、按照某种范围拆分例子： 用户表通过性别拆分为男用户表和女用户表 。订单表通过已完成和完成中拆分为已完成订单和未完成订单 4.读写分离：当一台服务器不能满足需求时，采用读写分离的方式进行集群，业务系统通常读多写少，可部署一主多从架构，主数据库负责写操作，并做双机热备，多台从数据库做负载均衡，负责读操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;读写分离出现了多个数据库，如何保持一致性的呢？ 比如 Mysql，它自己有一个master-slave功能，可以实现主库与从库数据的自动同步，是基于二进制日志复制来实现的。在主库进行的写操作，会形成二进制日志，然后Mysql会把这个日志异步的同步到从库上，从库再自动执行一遍这个二进制日志，那么数据就跟主库一致了 5.缓存：使用redis进行缓存 给数据库增加缓存系统，把热数据缓存到内存中，如果缓存中有请求的数据就不再去请求MySQL，减少数据库负载。缓存实现有本地缓存和分布式缓存，本地缓存是将数据缓存到本地服务器内存中或者文件中。分布式缓存可以缓存海量数据 6.选择合适的存储引擎！ Myisam:对事务要求不高，表锁，不支持外键，同时以查询和添加为主，就用这个。例如发帖和回帖Innodb:对事务要求很高，行锁，保存的都是很重要的数据，比如订单表 如何查找并定位慢查询的？？ 在项目转测试之前，在启动数据库的时候，开启慢查询，并且把执行慢的语句写到日志中，然后在运行一定的时间后，通过查看日志找到对应的慢查询语句。使用explain 慢查询语句，来详细分析语句的问题]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>优化</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm总结]]></title>
    <url>%2F2019%2F04%2F11%2Fjvm%2F</url>
    <content type="text"><![CDATA[对jvm进行总结一下 1.垃圾回收器基本都采用分代收集策略&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.虚拟机共划分为三个代：年轻代（Yong Generation）、老年代（Old Generation）和持久代（Permanent Generation）。其中的持久代指的就是方法区，持久代的内存回收目标主要是针对常量池的回收和对类的卸载，垃圾回收难度大，效果不理想。垃圾回收主要针对年轻代和老年代（Java 堆）中的对象回收。 2.判断对象是否存活的算法 1、给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1，引用失效就减1，任何时刻计数器为0的对象就是不能被使用了 2、可达性分析算法。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的 3.GC Roots的对象包括下面几种。注意都是引用的对象！！！ 1、虚拟机栈中引用的对象 2、方法区中类静态属性引用的对象 3、方法区中常量引用的对象 4、本地方法栈中Native方法引用的对象。 4.四个引用 1、强引用：类似“Object obj = new Object()”，这类引用，只要引用存在，就算内存空间不足了，GC也永远不会回收掉被引用的对象，而是抛出OOM异常 2、软引用：描述一些还有用但并非必要的对象。如果内存空间足够，GC就不会回收软引用关联的对象，如果内存空间不足了将要发生OOM异常时，GC将会把referent列入回收范围之中，进行第二次回收。如果回收了这些referent（第二次回收）后内存空间还不足够，则抛出OOM异常 3、弱引用：当发生GC时，无论内存是否足够，弱引用关联的到的对象都会被回收掉 4、虚引用的特点：即：虚引用不像其他三种引用一样会对对象的生存周期存在影响。被虚引用关联的对象能在被GC回收时收到一个系统通知 5.回收方法区（永久代） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要回收废弃的常量和无用的类、在大量反射，动态代理等这类频繁自定义classloader的场景都需要虚拟机具备类卸载的功能，以防永久代不会溢出 6.三个清除算法 1、标记清除法：首先标记处需要回收的对象，在标记完成时收掉这些对象。会产生碎片 2、复制算法：把可用的内存按容量划分成大小相等的两块，每次只用一块，当这一块的内存要用完了，把存活的对象复制到另一块上，然后清除已使用过的内存那一块。每次都是只对一块进行内存回收。不用考虑碎片 3、标记整理和清除差不多，但后续步骤不是直接对可回收的对象进行清除，而是让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存 7.新生代&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新生代还可以继续细分为三个区：一个Eden区和两个Survivor区（From Survivor区和To Survivor区），Eden区和Survivor区的比例可以通过SurvivorRatio来调节，默认为8。新生代可以使用的容量是90%。因为是8:1:1，只有10%可能被浪费掉 8.老年代&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在年轻代中经历了N次（所指定的晋升到老年代的阈值）垃圾回收（Mirror GC）的对象，就会被放到老年代中。因此，老年代中存放的都是一些生命周期较长的对象&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中。每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中 9.CMS收集器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是一种以获取最短回收停顿时间为目标的收集器。是基于“标记—清除”算法实现的，包括：初始标记（CMS initial mark），并发标记（CMS concurrent mark），重新标记（CMS remark），并发清除（CMS concurrent sweep）。总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;缺点：1.面向并发的都对cpu资源敏感，总吞吐量会降低。 2.标记清理收集结束会产生大量碎片， 9.G1垃圾收集器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;面向服务端应用的，特点如下：并行与并发，分代收集，空间整合（基于“标记—整理”算法实现的），不会产生内存碎片，非常精确的控制停顿，实现基本不牺牲吞吐量的前提下完成低停顿的内存回收 10.Minor GC触发条件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当Eden区满时，触发Minor GC；在MinorGC时，会把存活的对象复制到to space区域，如果to space区域不够，则利用担保机制进入老年代区域。 11.触发fullgc四个条件 1、 gc 担保失败——-在发生minorGC的时候，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，就直接进行一次fullGc,如果小于，则查看设置是否允许担保失败，如果允许，只会进行Minor gc，如果不允许就full gc 2、持久代（方法区）空间不足 3、老年代空间不足 4、调用System.gc 5、由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代 解Java的垃圾回收机制，就要从：“什么时候”，“对什么东西”，“做了什么”三个方面来具体分析 第一：“什么时候”即就是GC触发的条件。GC触发的条件有两种。（1）程序调用System.gc时可以触发；（2）系统自身来决定GC触发的时机。系统判断GC触发的依据：根据Eden区和From Space区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程。 第二：GC操作的对象分为：通过可达性分析法无法搜索到的对象和可以搜索到的对象。对于搜索不到的方法进行标记。 第三：对于搜索不到的对象，调用finalize()方法进行释放。具体过程：当GC线程启动时，会通过可达性分析法把Eden区和From Space区的存活对象复制到To Space区，然后把Eden Space和From Space区的对象释放掉。当GC轮训扫描To Space区一定次数后，把依然存活的对象复制到老年代，然后释放To Space区的对象&lt;其实就是复制算法&gt; jvm中一次完整的GC流程（从ygc到fgc）是怎样的，重点讲讲对象如何晋升到老年代等&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对象优先在新生代区中分配，若没有足够空间，Minor GC； 大对象（需要大量连续内存空间）直接进入老年态；长期存活的对象进入老年态。如果对象在新生代出生并经过第一次MGC后仍然存活，年龄+1，若年龄超过一定限制（15），则被晋升到老年态 重要的参数设置 1、-Xms：堆内存大小默认值 -Xmx：*堆内存最大值 2、-XX: PermSize：持久代（方法区）默认 -XX:MaxPermSize：*持久代（方法区）最大值 3、-Xss128k：设置每个线程的栈大小 5、-XX:NewSize=1024m：设置年轻代初始值为1024M。-XX:MaxNewSize=1024m：设置年轻代最大值为1024M。 6、-XX:NewRatio=4：设置年轻代（包括1个Eden和2个Survivor区）与年老代的比值。表示年轻代比年老代为1:4 7、-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的比值 被GC判断为”垃圾”的对象一定会回收吗&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要真正宣告一个对象死亡,至少要经历两次标记过程:如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链,那它将会被第一次标记并且进行一次筛选,筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法,或者finalize()方法已经被虚拟机调用过,虚拟机将这两种情况都视为“没有必要执行”。(即意味着直接回收)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果这个对象被判定为有必要执行finalize()方法,那么这个对象将会放置在一个叫做F-Queue的队列之中,并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。GC将对F-Queue中的对象进行第二次小规模的标记,如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试题</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合总结]]></title>
    <url>%2F2019%2F04%2F11%2Fjihe%2F</url>
    <content type="text"><![CDATA[对集合进行总结一下&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List：1.可以允许重复的对象。 2.可以插入null元素。 3.有序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list和set是实现了collection接口&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set：1.不允许重复对象 2. 无序容器，你无法保证每个元素的存储顺序。 3. 只允许一个 null 元素&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LinkedHashMap,LinkedHashSet,treeset,treemap是有序的 1.hashtable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安全，不可以存null，初始容量11，Api的方法都用synchronized 修饰，拉链法解决冲突，底层也是entry数组，Hashtable每次扩容，容量都为原来的2倍加1。 2.hashmap &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不安全，允许使用null的键值，初始值16，底层通过entry数组和链表实现，每个元素相当于一个桶bucket。 get方法:通过计算key的hashcode值来计算hash值，然后计算hash&amp;(length-1)取模得到在数组中的索引，然后通过key的equals方法在对应位置的链表中找到需要的元素 put方法：根据key的hashcode返回entry的位置，遍历entry数组，如果key对应的键值对已经存在，如果两个entry的key通过equals比较返回true则直接覆盖，否则添加到链表的头部 哈希表的容量为什么要是2的整数次幂？ 答：h&amp;(length-1)对length取模使得散列更加均匀，碰撞概率减小 JDK8中，链表节点数不小于8时，将不再以单链表的形式存储了，会被调整成一颗红黑树 扩容：1.创建时如果不指定容量初始值：元素超过16*0.75=12时，数组扩大一倍，重新计算元素位置，进行复制数组 如何减少碰撞？ 答：使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话 在多线程的情况下，当重新调整HashMap大小的时候? 答：会存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小，可能会产生死循环 3.ArrayList&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;底层是动态数组，不安全可重复，允许null，初始10，支持快速随机访问 ，扩容：1.5倍。。插入大量元素前，我可以使用 ensureCapacity 来手动增加 ArrayList 实例的容量，以减少递增式再分配的数量。 4.HashSet &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不可重无序，允许为Null，采用hash算法，底层用的是hashmap，容量，加载因子和map一样 5.LinkedList &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;底层是双向链表，不安全可重复，有序（链表），插入删除比较快 6.ConcurrentHashMap1.7版本的话：↓↓&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由一个Segment数组和多个HashEntry数组组成+ReentrantLock，Segment数组的意义：就是将一个大的table分割成多个小的table来进行加锁。而每一个Segment元素存储的是HashEntry数组+链表，允许16个线程并发使用 1.7的Put方法）：1.7的Put方法：Segment实现了ReentrantLock,也就带有锁的功能，当执行put操作时，会进行第一次key的hash来定位Segment的位置，如果该Segment还没有初始化，即通过CAS操作进行赋值，然后进行第二次hash操作，找到相应的HashEntry的位置，这里会利用继承过来的锁的特性，在将数据插入指定的HashEntry位置时（链表的尾端），会通过继承ReentrantLock的tryLock（）方法尝试去获取锁，如果获取成功就直接插入相应的位置，如果已经有线程获取该Segment的锁，那当前线程会以自旋的方式去继续的调用tryLock（）方法去获取锁，超过指定次数就挂起，等待唤醒 1.7get操作）：ConcurrentHashMap的get操作跟HashMap类似，只是ConcurrentHashMap第一次需要经过一次hash定位到Segment的位置，然后再hash定位到指定的HashEntry，遍历该HashEntry下的链表进行对比，成功就返回，不成功就返回null 1.7size操作）：计算ConcurrentHashMap的元素大小因为他是并发操作的，就是在你计算size的时候，他还在并发的插入数据，可能会导致你计算出来的size和你实际的size有相差（在你return size的时候，插入了多个数据）,JDK1.7版本用两种方案。第一种方案他会使用不加锁的模式去尝试多次计算ConcurrentHashMap的size，最多三次，比较前后两次计算的结果，结果一致就认为当前没有元素加入，计算的结果是准确的第二种方案是如果第一种方案不符合，他就会给每个Segment加上锁，然后计算ConcurrentHashMap的size返回 1.8版本的话：↓↓&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized+CAS+node数组+链表+红黑树的结构实现的，ConcurrentHashMap是一种键值对（K-V）形式的存储结构，键值对经过一定运算后首先存入数组对应的位置当中，当要存入的数组有值的时候，Map会生成一个链表挂在数组该位置（每个位置称为一个Hash桶），随着数据越存越多，链表会转换为红黑树。Map的默认大小是16，每次扩容翻倍，负载因子为0.75（数组超过0.75的负载之后进行扩容），链表长度超过8时转换为红黑树，红黑树节点小于6时转换回链表几个重要的参数：123456789101112131415161718192021222324252627282930313233343536//默认大小为16 private static final int DEFAULT_CAPACITY = 16; //默认并发数为16 private static final int DEFAULT_CONCURRENCY_LEVEL = 16; //负载参数为0.75 private static final float LOAD_FACTOR = 0.75f; //链表转换红黑树节点数阈值为8 static final int TREEIFY_THRESHOLD = 8; //红黑树转换链表节点数阈值为6 static final int UNTREEIFY_THRESHOLD = 6; //链表转换红黑树容量阈值为64（Map容量不到64时，链表转红黑树之前会先扩容） static final int MIN_TREEIFY_CAPACITY = 64; //Map对应的Hash桶数组 transient volatile Node&lt;K,V&gt;[] table; //扩容时候新建的Hash桶数组，注意transient关键字，该字段不会被序列化 private transient volatile Node&lt;K,V&gt;[] nextTable; //用于节点计数 private transient volatile long baseCount; //非常非常非常重要的一个参数，统御全局 //sizeCtl = -1，表示有线程正在进行初始化操作，防止多线程同时初始化Map //sizeCtl = -1代表正在初始化，-N代表有N-1个线程正在 进行扩容 //sizeCtl &gt; 0，表示接下来的初始化操作中的Map容量，或者表示初始化/扩容完成后的阈值 //sizeCtl = 0，默认值 private transient volatile int sizeCtl; //用以维护多线程扩容时候的线程安全 private transient volatile int transferIndex; 重要的内部类：1234567//节点的静态内部类，键值对存储的地方，只允许对数据进行查找，不允许进行修改 static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; //val值和下一个节点Node&lt;K,V&gt; next都被volatile关键字修饰，保证线程安全 volatile V val; volatile Node&lt;K,V&gt; next; 1.8的Put方法）:1.将Hash值进行高位与计算，使得高位和低位都参与运算，如果没有table,则初始化一个，初始化是懒汉为null才加载；没有hash冲突直接CAS插入；如果发现有个标志节点，说明还在进行扩容就先进行帮忙扩容；，如果存在Hash冲突，就加锁，锁住头结点，分两种情况： 1.链表,如果是相同的key就覆盖，否则就添加到尾部 2.红黑色就旋转插入， 如果链表的数量大于阈值8的话，转红黑树， 最后添加成功，统计size，并且检查是否需要扩容 1.8的Get方法）: 1.计算hash值，定位到该索引位置，如果是首节点符合就返回 2.如果遇到扩容的时候，会ForwardingNode的find方法或查找该节点，匹配就返回 3.以上都不符合的话，就往下遍历节点，否则最后就返回null 需要注意的地方：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.ForwardingNode的作用就是支持扩容操作，将已处理的节点和空节点置为ForwardingNode，并发处理时多个线程经过ForwardingNode就表示已经遍历了，就往后遍历扩容过程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 计算每个线程（CPU）要帮助处理多少个桶，默认每个线程处理16个桶。把原来的table复制到一个他两倍大小的nextTable中。将原来table元素转移到nexttable中，通常会把链表拆成2份（一个是原链表 另一个是原链表的反序），这里允许多线程进行操作（如果遍历到的节点是forward节点，就向后继续遍历，再加上给节点上锁）。每处理完一个节点就set为forward。如果完成扩容，CAS更新sizeCtl阈值，重新变为阀值，为新数组大小的0.75。此期间如果其他线程的有读写操作都会阻塞，并判断head节点是否为forwardNode节点，如果是就帮助扩容 何时扩容 1):每次新增节点之后会调用addCount方法计数，之后判断是否达到阈值（sizeCtl）并扩容 2):当链表中元素个数超过默认设定（8个），还要判整个table的数量小于64，就扩容至原来的一倍，否则将链表转化成红黑树 3):当发现其他线程扩容时，帮其扩容 在get()函数中并没有发现任何与锁相关的代码，怎么保证安全的？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 答：只要保证总是能够返回最新的数据 ，变量被关键字volatile修饰了 Size方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 答：你没法停下所有正在执行各种操作的线程们来统计准确数字，所以最终得到的只是个估计值，volatile 修饰值JDK1.8为什么使用内置锁synchronized来代替重入锁ReentrantLock??&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 答：因为粒度降低了，在相对而言的低粒度加锁方式，synchronized并不比ReentrantLock差，在粗粒度加锁中ReentrantLock可能通过Condition来控制各个低粒度的边界，更加的灵活，而在低粒度中，Condition的优势就没有了]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试题</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程总结]]></title>
    <url>%2F2019%2F04%2F10%2Fduoxiancheng%2F</url>
    <content type="text"><![CDATA[最近在准备面试，看了一些多线程的源码和书籍，对重点进行总结一下 1.线程池状态线程池实现原理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个线程集合workerSet和一个阻塞队列workQueue。当用户向线程池提交一个任务(也就是线程)时，线程池会先将任务放入workQueue中。workerSet中的线程会不断的从workQueue中获取线程然后执行。当workQueue中没有任务的时候，worker就会阻塞，直到队列中有任务了就取出来继续执行。 线程池被一旦被创建，就是running状态，能够接收新任务 调用了shutdown()方法，处于SHUTDOWN状态，不能够接受新任务，等待任务执行完毕； 调用了shutdownNow()方法，处于STOP状态，不能接受新的任务，会去尝试中断正在执行的任务； 当线程池处于SHUTDOWN或STOP状态，阻塞队列为空并且线程池执行的任务也为空，就会由 SHUTDOWN -&gt; TIDYING。 线程池彻底终止，就变成TERMINATED状态 2.线程池执行流程 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提交任务分为execute()和submit()方法：execute()方法用于提交不需要返回值的任务，无法判断是否成功；submit方法用于提交需要返回值的任务，会返回一个future类型的对象，通过该对象可以判断任务是否执行成功，.get()方法获取返回值 当线程池的数目小于corepoolsize,创建新的线程执行任务 当线程池的数目&gt;=corepoolsize,并且阻塞队列没满时，把新任务放入阻塞队列 当阻塞队列满了，并且corepoolsize&lt;=线程池数目&lt;maximumpoolsize，创建新的线程执行任务 当阻塞队列满了，线程池数目&gt;=maximumpoolsize，采取拒绝策略，默认抛出异常 重要参数 1）corePoolSize ： 核心线程池的实现大小，当提交一个任务时，线程池会创建一个线程来执行任务，即使有空闲线程也会创建一个新的，等到需要执行的任务数大于线程池基本大小时就不再创建。。换句话说：表示允许线程池中允许同时运行的最大线程数。 2）maximumPoolSize ： 最大线程池的实现大小，如果队列满了，并且已经创建的线程数小于最大线程数，则线程池会创建新的线程去执行任务 3）keepAliveTime ：线程活动保持时间，线程空闲超过这个时间就会终止 4）handler ： 当ThreadPoolExecutor已经关闭或已经饱和时，execute()方法将调用Handler 3.阻塞队列有哪些 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原理：用的是Node节点组成的双向链表，可以对头尾两端插入删除，支持先进先出和后进先出的模式，使用通知模式，就是当生产者往满的队列加元素时，会阻塞，当消费者消费了一个元素，会通知生产者当前队列可用，使用了condition和ReentrantLock 1）ArrayBlockingQueue：基于数组的先进先出队列 2）LinkedBlockingQueue：基于链表的先进先出队列 3）synchronousQueue：它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。 4.无界队列（永远不会阻塞，底层都使用CAS无锁）：ConcurrentLinkedQueue &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConcurrentLinkedQueue 由head节点和tail节点组成，每个节点（Node）由节点元素（item）和指向下一个节点的引用(next)组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。默认情况下head节点存储的元素为空，tail节点等于head节点 1）入队过程：第一把入队节点当成尾节点的下一个节点，第二是使用CAS算法能将入队节点设置成尾节点的next节点，如不成功则重试（如果tail节点的next节点不为空，则将入队节点设置成tail节点，如果tail节点的next节点为空，则将入队节点设置成tail的next节点，所以tail节点不总是尾节点） 2）出队：首先获取头节点的元素，然后判断头节点元素是否为空，如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走，如果不为空，则使用CAS的方式将头节点的引用设置成null，如果CAS成功，则直接返回头节点的元素，如果不成功，表示另外一个线程已经进行了一次出队操作更新了head节点，导致元素发生了变化，需要重新获取头节点 5.介绍一下synchronized&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;锁是存在Java对象头里的,对象头主要包括两部分数据：Mark Word（标记字段）、类型指针,Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键。jdk1.6之后 锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态 1）自旋锁：线程的阻塞和唤醒需要cpu从用户态转为核心态，频繁的话对cpu负担很重，如果对象锁的状态只持续很短一段时间，可以用自旋。让线程等待一段时间，不会被立即挂起，自己执行一段空循环（自旋）等待 2）偏向锁：锁不存在多线程竞争，总是由同一个线程多次获得 3）偏向锁：轻量级锁：不会阻塞，得不到锁就会自旋 4）重量级：不会自旋，不会消耗cpu，线程阻塞 6.重排序 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在执行程序时，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件： 1）在单线程环境下不能改变程序运行的结果； 2）存在数据依赖关系的不允许重排序 7.AQS &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原理：AQS设计模式采用模板方法，子类通过继承实现它的抽象方法来管理同步状态。在AQS内部维护着一个FIFO的同步队列。首先判断同步状态state==0，如果是0说明没有被线程持有，就尝试获取同步状态，当线程获取同步状态失败后，会加入到这个队列并开始自旋。在自旋时，会判断前继节点是不是首节点，如果是就不断尝试获取同步状态，获取成功则把自己设置为head结点。在释放同步状态时，则通过调用子类(ReetrantLock中的Sync内部类)的tryRelease(int releases)方法释放同步状态，释放成功则唤醒后继结点的线程 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内部实现了3个类，分别是Sync、NoFairSync以及FairSync类，其中Sync继承自AQS，实现了释放锁的模板方法，而NoFairSync和FairSync都继承自Sync，实现各种获取锁的方法。又分为共享式和独占式。区别在于同一时刻独占只能有一个线程获取同步状态，而共享可以有多线程获取同步状态，例如读操作可以有多个线程同时进行，而写操作只能有一个线程进行写，其他操作会阻塞 8.Condition接口 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;能够精细的控制多线程的休眠与唤醒，可以为多个线程间建立不同的Condition。具体实现类是AQS的内部类ConditionObject；ConditionObject中有两个结点分别是firstWaiter和lastWaiter，firstWaiter代表等待队列第一个等待结点，lastWaiter代表等待队列最后一个等待结点 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结：一个线程获取锁喉，调用condition的await()方法，会先把当前线程封装成node结点加入等待队列，然后释放同步状态并唤醒后继结点的线程，判断该结点是否在同步队列中，如果在就不断尝试获取锁，否则挂起。 signal()被调用后，先判断当前线程是否持有独占锁，如果有，那么唤醒等待队列的第一个结点，并从等待队列中移除该结点，移动到同步队列中 9.happens-before &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;概念来指定两个操作之间的执行顺序。 关系的定义如下 1）如果A happens-before B A操作的结果将对B可见，且A的执行顺序排在B之前 2）遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行 10.CAS 即比较交换&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CAS(V,E,N) V表示要更新的变量，E表示预期值，N表示新值CAS操作需要我们提供一个期望值，当期望值与当前线程的变量值相同时，说明还没线程修改该值，当前线程可以进行修改，也就是执行CAS操作，但如果期望值与当前线程不符，则说明该值已被其他线程修改，此时不执行更新操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.CAS操作属于乐观派，没有锁的存在，因此不可能出现死锁的情况&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.CAS是一条CPU的原子指令，不会造成数据不一致问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.CAS操作的执行依赖于Unsafe类的方法，Unsafe类中的所有方法都是native修饰的，也就是说方法都直接调用操作系统底层资源执行相应任务 11.ABA问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CAS操作容易引起ABA问题。ABA问题：假设第一个线程执行CAS(V,E,U)操作，在获取到当前变量V，准备修改为新值U前，另外两个线程已连续修改了两次变量V的值，使得该值又恢复为旧值，这样的话，我们就无法正确判断这个变量是否已被修改过&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决方法：每次修改后，AtomicStampedReference不仅会设置新值而且还会记录更改的时间&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compareAndSwapObject(Object o, long offset,Object expected, Object x)参数的意义&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个参数o为给定对象，offset为对象内存的偏移量， expected表示修改之前的值，x表示要更新的值 12.countdownlatch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;允许一个或多个线程等待其他线程完成操作。在创建实例的时候，需要传递一个count参数，为计数器的初始值，当某个线程调用await()方法时，先判断count是否为0，如果不是0就一直等待到0为止，其他线程调用countdown方法时，使得count-1，直到count=0，锁才会释放，前面等待的线程才会继续执行 13.Semaphore&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个计数信号量。从概念上讲，信号量维护了一个许可证。如有必要，在许可证可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release() 添加一个许可，从而可能释放一个正在阻塞的获取者 14.CyclicBarrier&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它允许一组线程相互等待直到所有线程都到达一个公共的屏障点。在程序中有固定数量的线程，这些线程有时候必须等待彼此，这种情况下，使用CyclicBarrier很有帮助。这个屏障之所以用循环修饰，是因为在所有的线程释放彼此之后，这个屏障是可以重新使用的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[人满发车]这个词来理解比较好，满20人就发车 15.线程的实现方式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有四种：继承Thread类、实现Runnable接口、实现Callable接口通过FutureTask包装器来创建Thread线程、使用线程池创建&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里介绍一下第三种：实现Callable接口123456789class ThreadDemo implements Callable&lt;Integer&gt; &#123; public Integer call() throws Exception &#123; return ....; &#125;&#125; // 1.执行Callable方式，需要FutureTask实现类的支持，用于接收运算结果 FutureTask&lt;Integer&gt; result = new FutureTask&lt;&gt;(td); new Thread(result).start(); //等所有线程执行完，获取值，因此FutureTask 可用于 闭锁 sum = result.get(); 16.ThreadLocal与synchronized本质的区别:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副本，使得不同的线程访问同一个ThreadLocal,但是他们获取的值不一样，这样就隔离了多个线程对数据的数据共享. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）在ThreadLocal类中有一个Map，用于存储每一个线程的变量的副本 17.重校验锁实现对象单例1234567891011121314151617 public class Singleton &#123; private volatile static Singleton uniqueInstance; private Singleton() &#123; &#125; public static Singleton getUniqueInstance() &#123; //先判断对象是否已经实例过，没有实例化过才进入加锁代码 if (uniqueInstance == null) &#123; //类对象加锁 synchronized (Singleton.class) &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125; 18.同步方法的原理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized方法反汇编之后，在常量池中会有ACC_SYNCHRONIZED标示符， JVM就是根据该标示符来实现方法的同步的，当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象，会被阻塞 19.同步代码块的原理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JVM使用monitorenter和monitorexit两个指令实现同步。即JVM为代码块的前后真正生成了两个字节码指令来实现同步功能的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在JVM中synchronized是通过监视器(monitor)来控制线程的访问，每个对象都会与一个monitor相关联，当某个monitor被拥有之后就会被锁住，当线程执行到monitorenter指令时，就会去尝试获得对应的monitor。步骤如下： 1）每个monitor维护着一个记录着拥有次数的计数器。未被拥有的monitor的该计数器为0，当一个线程获得monitor（执行monitorenter）后，该计数器自增变为 1 。 当同一个线程再次获得该monitor的时候，计数器再次自增； 当不同线程想要获得该monitor的时候，就会被阻塞。 2） 当同一个线程释放 monitor（执行monitorexit指令）的时候，计数器再自减。当计数器为0的时候。monitor将被释放，其他线程便可以获得monitor 其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法 20.Java内存模型&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;描述了在多线程代码中哪些行为是合法的，以及线程如何通过内存进行交互内存模型实现总是从主内存（共享内存）读取变量，在当前的内存模型下，线程可以把变量保存到本地内存（比如cpu的寄存器或者cpu的缓存中）！&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这可能造成数据不一致，另一个线程已经修改了寄存器里的变量值，一个线程还在使用要解决这个问题的话，把变量声明成volatile，不稳定，因为每次都要去主内存读！！ 21.对线程安全的理解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;线程安全就是多线程访问时，采用了加锁机制或者原子类或者线程安全的类，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读/写完，其他线程才可使用。不会出现数据不一致或者数据污染 22.死锁 1）互斥条件：一个资源每次只能被一个进程使用 2）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 3）不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺 4）循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系 预防：减少锁竞争，减少持有资源的时间，有序分配资源死锁排查：1.利用 jstack 等工具获取线程栈，然后定位互相之间的依赖关系，进而找到死锁。如果是比较明显的死锁，往往 jstack 等就能直接定位，类似 JConsole 甚至可以在图形界面进行有限的死锁检测]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[async基础用法]]></title>
    <url>%2F2019%2F04%2F10%2Fasynbiji%2F</url>
    <content type="text"><![CDATA[async就是异步的意思， 异步函数也就意味着该函数的执行不会阻塞后面代码的执行 先来一段代码12345async function timeout()&#123; return &quot;hello world&quot; &#125; timeout(); console.log(&apos;我在后面，但是我先执行的&apos;) 输出结果只输出了一句。async 函数 timeout 调用了，但是没有任何输出，它不是应该返回 ‘hello world!于是我们打印一下发现async 函数返回的是一个promise 对象，如果要获取到promise 返回值，我们应该用then 方法1234567async function timeout() &#123; return &apos;hello world&apos;&#125;timeout().then(result =&gt; &#123; console.log(result);&#125;)console.log(&apos;虽然在后面，但是我先执行&apos;); await是等待的意思，注意await 关键字只能放到async 函数里面await 后面放置的就是返回promise对象的一个表达式，所以它后面可以写上 doubleAfter2seconds 函数的调用 12345678910111213// 2s 之后返回双倍的值 function doubleAfter2seconds(num) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(2 * num) &#125;, 2000); &#125; ) &#125; async function testResult() &#123; let result = await doubleAfter2seconds(30); console.log(result); &#125; testResult(); //2s后输出60 看看代码的执行过程，调用testResult 函数，它里面遇到了await, await 表示等一下，代码就暂停到这里，不再向下执行了，它等什么呢？等后面的promise对象执行完毕，然后拿到promise resolve 的值并进行返回，返回值拿到之后，它继续向下执行。具体到 我们的代码, 遇到await 之后，代码就暂停执行了， 等待doubleAfter2seconds(30) 执行完毕，doubleAfter2seconds(30) 返回的promise 开始执行，2秒 之后，promise resolve 了， 并返回了值为60， 这时await 才拿到返回值60， 然后赋值给result， 暂停结束，代码才开始继续执行，执行 console.log语句。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高频面试题总结]]></title>
    <url>%2F2019%2F04%2F10%2Fjavajc%2F</url>
    <content type="text"><![CDATA[1.Java中的异常有哪几类？分别怎么使用？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非运行需要try…catch才能编译通过。运行时异常不用try…catch也能编译通过。RuntimeException是运行时异常，不需要try…catch也能编译通过。IoException，SQLException等等其他所有异常都是检出异常，必须要try…catach才能编译通过。 2.请简述http协议中get请求和post请求的区别？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;()get请求参数会添加到url链接的后缀，如果是多个以&amp;符合连接，get请求可以被缓存，post不可以缓存，对数据长度是没有限制的Post请求的参数是存储在方法体里的；get传的参数会暴露在外面，不安全。GET产生一个TCP数据包；POST产生两个TCP数据包 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；一趟 对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。二趟哦 3.简述session和cookie区别&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session安全性高一点，存储在服务器端的，大小没有限制；Cookie存储在浏览器上的，单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。Cookie有可能会被人盗用。session的sessionID是放在cookie里，要想功破session的话，第一要功破cookie。功破cookie后，你要得到 sessionID,sessionID是要有人登录，或者启动session_start才会有，你不知道什么时候会有人登录。 4.servlet和Jsp关系 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jsp本质就是servlet,jsp jsp执行时会被编译成servlet在JSP中，更加注重页面的表现，而在Servlet中则更注重业务逻辑的实现 5.java能跨平台？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JVM（java虚拟机）来把字节码再“翻译”成所对应的硬件平台能够执行的代码 6.==和equals的区别 1）作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等.如果作用于引用类型的变量，则比较的是所指向的对象的地址 2）对于equals方法，注意：equals方法不能作用于基本数据类型的变量 。如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；。 诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。 7.简述泛型，反射，注解应用场景以及解决了什么问题 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;泛型编译时检查我们的类型安全，并且消除了类型的强制转换； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反射对于任意一个类(Class对象)，都能够知道这个类的所有属性和方法，也可以通过这个Class对象来创建类的实例 8.final关键字用法 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 修饰类，无法被继承 2.修饰方法，无法被重写3.修饰变量，该变量只能被赋值一次，且值无法被改变（常量） 9.String,StringBuffer,StringBuilder区别 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String，StringBuilder是线程不安全的，而StringBuffer是线程安全的。String不可变，其余可变 10.写出一条Sql语句，查询表A中存在Id重复三次以上的记录&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select *From A Where id in(select ID from A group by id having count(id)&gt;3) 11.mybatis中#{…} 和${…} 的区别&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“#{}”可以防止sql注入攻击，因为会将传入的数据加上 ${}：表示sql拼接，如果获取简单类型，${}中只能使用value。 #{}：表示占位符，如果获取简单类型，#{}中可以使用value也可以使用其他名称 12.mysql事务的四大特性 1）原子性：一个事务为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚 2）一致性：不能破坏关系数据的完整性 3）隔离性（isolation）：一个事务所做的修改在最终提交以前，对其他事务是不可见的 4）持久性（durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中 13.mysql事务的隔离级别 1）读未提交：就是一个事务可以读取另一个未提交事务的数据–会引起脏读 2）读提交，能解决脏读，事务A 多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致–会引起不可重复读 3）重复读（默认隔离级别），就是在开始第一次读取数据时，不再允许修改操作。就将这些数据加锁（悲观锁），其它事务无法修改这些数据，就可以实现可重复读了–幻读（另一个事务insert操作，而不是update 4）Serializable 序列化：都可以防止，效率比较低 注意：不可重复读侧重于修改，幻读侧重于新增或删除 14.前端浏览器地址的一个Http请求到后端完整流程 1）URL解析/通过DNS把域名解析成ip地址。。详细：对url进行检查，判断协议是http/https按照web处理/DNS解析先搜索浏览器自身的dns缓存，再搜索系统自身的dns缓存，再去Host文件找，在没有就继续向上层找缓存，如果都没有就去域名服务器找 2）通过ARP协议获得IP地址对应的物理地址。发起HTTP请求，建立tcp三次握手的连接。HTTP请求报文由三部分组成：请求行，请求头、空行和请求数据4部分组成 3）服务器接收数据，响应请求。。HTTP响应报文主要由状态行、响应头部、空行以及响应数据组成。状态码：1xx提示信息，2xx表示请求成功，3xx表示重定向，4xx客户端错误，5xx表示服务端错误 4）服务器返回数据，关闭tcp连接用四次挥手 5）客户端接收数据。。浏览器加载/渲染页面（如果是200就渲染，300重定向，400，500报错页面） 15.为什么这条sql执行慢 1）数据库在刷新脏页，redo log写满了需要同步到磁盘上—–当往数据库插入一条数据，或者要更新一条数据时，我们知道数据库会在内存中把对应的字段更新了，但是更新之后，并不会马上同步持久化到磁盘中去，而是把更新的记录写入到redo log日记中去，等到空闲时在通过redo log里的日记把最新的数据同步到磁盘里去 2）拿不到锁—-执行的这条语句刚好这条语句涉及到的表，别人在用，并且加锁了，或者加了行锁。可以用show processlist命令来查看当前的状态 3）没用到索引，全表扫描 16.数据库三大范式怎么理解的 1）每个字段都是不可拆分的；若一列有多个值，可进行拆分；例如经常访问地址这个属性，可以重新拆分成省，市，详细地址进行存储 2）每一行的所有非主属性都必须完全依赖于主键，确保每一列都和主键相关!! 比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关.所以把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中 3）属性不依赖于其他非主属性！如果一个实体中出现其他实体的非主属性，可以将这两个实体用&lt;外键关联&gt;。比如在设计一个订单数据表，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。 17.tcp和udp的区别 1）**TCP：是面向连接的流传输控制协议，具有高可靠性，确保传输数据的正确性，有验证重发机制，因此不会出现丢失 2）**UDP：是无连接的数据报服务，无须等待对方的应答，会出现分组丢失、重复、乱序，但具有较好的实时性，UDP段结构比TCP的段结构简单，因此网络开销也小 18.TCP为什么不是两次连接？而是三次握手？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果A与B两个进程通信，如果仅是两次连接。可能出现的一种情况就是：A发送完请报文以后，由于网络情况不好，出现了网络拥塞，即B延时很长时间后收到报文，即此时A将此报文认定为失效的报文。B收到报文后，会向A发起连接。此时两次握手完毕，B会认为已经建立了连接可以通信，B会一直等到A发送的连接请求，而A对失效的报文回复自然不会处理。依次会陷入B忙等的僵局，造成资源的浪费。 19.tcp连接建立的时候3次握手，断开连接的4次握手的具体过程 1）**建立连接采用的3次握手协议，具体是指：第一次握手是客户端connect连接到server，server accept client的请求之后，向client端发送一个消息，相当于说我都准备好了，你连接上我了，这是第二次握手，第3次握手就是client向server发送的，就是对第二次握手消息的确认。之后client和server就开始通讯了。 2）**断开连接的4次握手,具体如下：断开连接的一端发送close请求是第一次握手，另外一端接收到断开连接的请求之后需要对close进行确认，发送一个消息，这是第二次握手，发送了确认消息之后还要向对端发送close消息，要关闭对对端的连接，这是第3次握手，而在最初发送断开连接的一端接收到消息之后，进入到一个很重要的状态time_wait状态，这个状态也是面试官经常问道的问题，最后一次握手是最初发送断开连接的一端接收到消息之后。对消息的确认 4次挥手:可以这么理解：A客户端：兄弟，我们关闭连接，没数据要传了 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B服务端：收到，我看看我这边有没有数据 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B服务端：兄弟，我这边也没数据要传你了，关闭吧 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A：好的 20.重写equals为何要重写hashCode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;判断两个对象是否相等，比较的就是其hashCode, 如果你重载了equals，比如说是基于对象的内容实现的，而保留hashCode的实现不变，那么很可能某两个对象明明是“相等”，而hashCode却不一样。 hashcode不一样，就无法认定两个对象相等了 21.JVM加载class文件的原理机制&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JVM中类的装载是由类加载器和它的子类来实现的，当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化 22.java服务部署在linux服务器上，服务器进程突然消失了，列举原因，及其定位思路和方法 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、Java应用程序的问题：发生OOM导致进程Crash通过生成设置参数，生成快照，然后通过分析工具分析快照即可&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、JVM出错：JVM或JDK自身的Bug导致进程Crash当JVM出现致命错误时，会生成一个错误文件 hs_err_pid.log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、操作系统OOM-Killer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step1: 查看操作系统日志：sudo grep –color “java” /var/log/messages，确定Java进程是否被操作系统Kill；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step2: 若被操作系统Kill，执行dmesg命令查看系统各进程资源占用情况，明确Java占用内存是否合理，以及是否有其它进程不合理的占用了大量内存空间 23.Innodb默认的事务隔离级别是哪种？在该隔离级别下，列出有可能出现的情况（脏读，不可重复读，幻读）____？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;出现”幻读“。默认是可重复读的(REPEATABLE READ) 24.找101-200之间素数123456789101112131415161718public static void main(String[] args) &#123; int count=0; for (int i=101; i&lt;200; i++) &#123; if (PrimeNumber(i)) &#123; count++; System.out.print(i+&quot; &quot;); &#125; &#125; System.out.println(&quot;\n101~200之间共有：&quot;+count+&quot;个素数&quot;); &#125; private static boolean PrimeNumber(int n) &#123; if (n==2) return true; for (int i=2; i&lt;=n/2; i++) &#123; if (n%i==0) return false; &#125; return true; &#125;&#125; 25.Hibernate工作原理及为什么要用？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3个核心接口 :Configuration、SessionFactory、Session &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、利用Configuration读取并解析配置文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、通过配置文件创建SessionFactory ，初始化hibernate基本信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、打开Sesssion，创建事务&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、持久化操作&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、提交事务，关闭session和sessionfactory 26.什么是di，ioc &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、ioc：控制反转.应用不负责依赖对象的创建和维护,依赖对象的创建及维护是由外部容器（例如spring）负责的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、di:依赖注入。在程序运行期间,由外部容器动态地将依赖对象注入到组件中 如：一般通过构造函数注入或者setter注入。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot面试题总结]]></title>
    <url>%2F2019%2F04%2F10%2Fspringbootmst%2F</url>
    <content type="text"><![CDATA[最近在准备面试，对考点频繁的面试题进行总结一下 1.什么是SpringBoot&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、用来简化spring初始搭建和开发过程使用特定的方式进行配置(properties或者yml文件)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、创建独立的spring程序在main方法运行&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、嵌入Tomcat无需部署war包&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、自动配置spring添加对应的starter自动化配置2.SpringBoot自动配置原理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、@EnableAutoConfiguration这个注解会”猜”你将如何配置spring，前提是你已经添加了jar依赖项，如果spring-boot-starter-web已经添加Tomcat和SpringMVC，这个注释就会自动假设您在开发一个web应用程序并添加相应的spring配置，会自动去maven中读取每个starter中的spring.factories文件，该文件里配置了所有需要被创建spring容器中bean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、在main方法中加上@SpringBootApplication和@EnableAutoConfiguration 3.服务调用的原理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;服务调用有以下几个：rest、feign（均使用httpclient技术），负载均衡ribbon。服务首先注册到注册中心eureka中(注册一个名字通过名字调用) ；负载均衡。ribbon，先去注册中心取到对应的服务，然后交给ribbon 4.springcloud如何实现服务注册与发现？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;服务发布时指定对应的服务名(IP地址和端口号)，将服务注册到注册中心(eureka和zookeeper)，但是这一切是Springcloud自动实现的，只需要在SpringBoot的启动类上加上@EnableDisscoveryClient注解，同一服务修改端口就可以启动多个实例调用方法：传递服务名称通过注册中心获取所有的可用实例，通过负载均衡策略(Ribbon和Feign)调用对应的服务 5.Ribbon和Feign的区别：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、Ribbon添加的maven依赖是spring-starter-ribbon，使用@RibbonClient(value=“服务名称”)使用RestTemplate调用远程服务对应的方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、Feign添加的maven依赖是spring-starter-feign，服务提供方提供对外接口，调用方使用，在接口上使用FeignClient(“指定服务名”)具体区别： 1）启动类使用的注解不同，Ribbon使用的是@RibbonClient，Feign使用的是@EnableFeignClients 2）服务的指定位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明 3）调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤比较繁琐。Feign则是在Ribbon的基础上进行了一次改进，采用接口调用的方式，将需要调用的其他服务的方法定义成抽象方法即可，不需要自己构建http请求，不过要注意的是抽象方法的注解、方法签名要和提供方的完全一致。 6.雪崩效应&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分布式系统中的服务通信依赖于网络，网络不好，必然会对分布式系统带来很大的影响。在分布式系统中，服务之间相互依赖，如果一个服务之间出现了故障或者网络延迟，在高并发的情况下，会导致线程阻塞，在很短的时间内该服务的线程资源会消耗殆尽，最终使得该服务不可用。由于服务的相互依赖，可能会导致整个系统的不可用，这就是“雪崩效应”。为了防止此类事件的发生，分布式系统必然要采取相应的措施，如熔断机制（Springcloud采用的是Hystrix） 7.熔断机制 1）当一个服务出现故障时，请求失败次数超过设定的阀值（默认50）之后，该服务就会开启熔断器，之后该服务就不进行任何业务逻辑操作，执行快速失败，直接返回请求失败的信息。其他依赖于该服务的服务就不会因为得不到响应而造成线程阻塞，这是除了该服务和依赖于该服务的部分功能不可用外，其他功能正常 2）熔断器还有一个自我修复机制，当一个服务熔断后，经过一段时间（5s）半打开熔断器。半打开的熔断器会检查一部分请求（只能有一个请求）是否正常，其他请求执行快速失败，检查的请求如果响应成功，则可判断该服务正常了，就可关闭该服务的熔断器，反之则继续打开熔断器。这种自我熔断机制和自我修复机制可以使程序更加健壮、也可以为开发和运维减少很多不必要的工作 3）熔断组件往往会提供一系列的监控，如：服务可用与否、熔断器是否被打开、目前的吞吐量、网络延迟状态的监控等，从而可以让开发人员和运维人员的了解服务的状况 8.Eureka和zookeeper区别&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、Zookeeper—–当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的信息，但不能容忍直接down掉不可用的。也就是说服务注册功能对高可用性要求比较高，但是zk会出现这样的一种情况，当master节点因为网络故障与其他节点失去联系时，剩余的节点会重新选leader。问题在于，选取leader的时间过长(30~120s)，且选取期间zk集群都不可用，这样就会导致选取期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务最终恢复，但是漫长的选择时间导致的注册长期不可用是不能容忍的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、Eureka则看明白这一点，因此再设计的优先保证了高可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响到正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端再向某个Eureka注册时如果发现连接失败，则会自动切换至其他节点，只要有一台Eureka还在，就能保证注册服务的可用(保证可用性)，只不过查到的信息可能不是最新的(不保证一致性)。除此之外Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时就会出现以下几种情况： 1）Eureka不再从注册列表移除因为长时间没收到心跳而应该过期的服务 2）Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(保证当前节点可用) 3）当网络稳定时，当前实例新的注册信息会被同步到其它节点中 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.Eureka还有客户端缓存功能(Eureka分为客户端程序和服务器端程序两个部分，客户端程序负责向外提供注册与发现服务接口)。所以即便Eureka集群中所有节点都失效，或者发生网络分隔故障导致客户端不能访问任何一台Eureka服务器；Eureka服务的消费者任然可以通过Eureka客户端缓存来获取所有的服务注册信息。甚至最极端的环境下，所有正常的Eureka节点都不对请求产生响应也没有更好的服务器解决方案来解决这种问题时；得益于Eureka的客户端缓存技术，消费者服务仍然可以通过Eureka客户端查询与获取注册服务信息，这点很重要，因此Eureka可以很好的应对网络故障导致部分节点失去联系的情况，而不像Zookeeper那样使整个注册服务瘫痪]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[费用报销系统的总结]]></title>
    <url>%2F2019%2F02%2F24%2F%E5%BD%AD%E4%BA%8E%E6%99%8F%2F</url>
    <content type="text"><![CDATA[1.多线程实现爬虫改善&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里以爬取某个区的所有街道为例&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是福田区下的街道办事处，可以看到街道后面还有链接是居委会。我们可以发现街道的话有个&lt;tr class=”towntr’&gt;”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是居委会，就是我们最后的数据，可以发现居委会有&lt;tr class=”villagetr’&gt;的标签遍历&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;思路如下：开启10个线程，每次都锁住线程，一开始有一个地址，所以移出并弹出，然后根据该地址进行爬取document，有可能别的线程快先爬取到了最后面，所以我们要判断当前是不是最后，是的话就走另一个分支（取出vill这个td），然后再输出第三个element.text的名字。如果不是最后就添加到阻塞队列回去，说明还没遍历到最后&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解释一下线程池为什么要阻塞队列：阻塞队列主要是用于生产者-消费者模型的情况。比如一个线程从一个空的阻塞队列中取元素，此时线程会被阻塞直到阻塞队列中有了元素。当队列中有元素后，被阻塞的线程会自动被唤醒（不需要我们编写代码去唤醒）。这样提供了极大的方便性。如果使用非阻塞队列，它不会对当前线程产生阻塞，就必须额外地实现同步策略以及线程间唤醒策略，这个实现起来就非常麻烦。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public class App2 &#123; public static final LinkedBlockingQueue&lt;String&gt; UrlQueue=new LinkedBlockingQueue&lt;&gt;(); //阻塞队列,不指定大小的话默认大小为Integer.MAX_VALUE就是无界，也可以是有界 //底层是通过ReentrantLock和Condition条件来保证多线程的正确访问的，并且取元素（出队列）和存元素（入队列）是采用不同的锁 public static void main(String[] args) &#123; // 确定目标地址 URL 统一资源定位符 String url=&quot;http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2017/44/03/440304.html&quot;; Runnable runnable=new MyRunnable(); ExecutorService fixed = Executors.newFixedThreadPool(10); UrlQueue.offer(url); //offer操作，向队列尾部插入，没有满添加元素，返回true, 满了的话，返回false long startTime = System.currentTimeMillis(); //获取开始时间 System.out.println(&quot;begin &quot;+startTime); for (int i = 0; i &lt; 10; i++) &#123; fixed.submit(runnable); &#125; fixed.shutdown(); &#125; public static boolean IsNumber(String str)&#123; Pattern pattern = Pattern.compile(&quot;[0-9]*&quot;); Matcher isNum = pattern.matcher(str); if( !isNum.matches() )&#123; return false; &#125; return true; &#125;&#125;class MyRunnable implements Runnable&#123; public void run() &#123; while (true)&#123; try &#123; Thread.sleep(200); synchronized (this) &#123; if (!UrlQueue.isEmpty()) &#123; String url = UrlQueue.take(); //take 操作，获取当前队列头部元素并从队列里面移除，如果队列为空则阻塞调用线程 System.out.println(&quot;取出Url---&quot;+url); Document doc = Jsoup.connect(url) .timeout(500000).get(); ArrayList&lt;String&gt; UrlList= AnalysisDocument(url, doc); for (String urltemp:UrlList ) &#123; System.out.println(&quot;/// &quot;+urltemp); UrlQueue.put(urltemp); &#125; //打印URL队列中的URL条数以及队列是否为空 System.out.println(UrlQueue.size()); System.out.println(UrlQueue.isEmpty()); //为空说明爬取完毕 if (UrlQueue.isEmpty()) &#123; System.out.println(&quot;抓取完毕！&quot;); System.exit(1); &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; private ArrayList&lt;String&gt; DataAccess(HashMap&lt;String, ArrayList&lt;String&gt;&gt; Message) &#123; //数据处理，把信息中的Url返回给核心，文本信息储存 return Message.get(&quot;Url&quot;); &#125; private ArrayList&lt;String&gt; AnalysisDocument(String url, Document doc) &#123; //从 Doc 的树形结构中查找 img 标签 //.class 选择器 Elements document = doc.select(&quot;.towntr a&quot;); //URL的拼接，这是前半部分 String Before_Url = url.substring(0, url.lastIndexOf(&quot;/&quot;) + 1); //储存Url的List ArrayList&lt;String&gt; Urls = new ArrayList&lt;&gt;(); HashMap&lt;String, ArrayList&lt;String&gt;&gt; Message = new HashMap&lt;&gt;(); //最后一个页面的前三个文本不要 int Flag = 1; HashMap&lt;String,ArrayList&lt;String&gt;&gt; mess = new HashMap&lt;&gt;(); //最后一个页面的处理 if (document.isEmpty()) &#123; document = doc.select(&quot;.villagetr td&quot;); System.out.println(url+&quot; 到尾巴了 &quot;); for (Element element : document) &#123; if (!IsNumber(element.text()) &amp;&amp; Flag &gt;= 3) &#123; System.out.println(element.text()); &#125; Flag++; &#125; //普通页面的处理 &#125; else &#123; for (Element element : document) &#123; if (!IsNumber(element.text())) &#123; String zhi = element.text(); System.out.println(&quot; read &quot;+zhi); String valueurl = Before_Url + element.attr(&quot;href&quot;); Urls.add(valueurl); &#125; &#125; &#125; return Urls; &#125;&#125; 2.策略模式优化if-else代码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;策略模式实现了对具体策略之间的互换，客户端知道一个行为可以产生怎样的结果，而这个行为是怎样的就通过传入具体的策略来实现&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面举个例策略模式+工厂模式优化if…else 结构&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;改善后的代码如下：↓↓ 1234567891011121314151617181920212223242526272829303132public enum RechargeTypeEnum &#123; E_BANK(1, &quot;网银&quot;), BUSI_ACCOUNTS(2, &quot;商户账号&quot;), MOBILE(3,&quot;手机卡充值&quot;), CARD_RECHARGE(4,&quot;充值卡&quot;); private int value; private String description; private RechargeTypeEnum(int value, String description) &#123; this.value = value; this.description = description; &#125; public int value() &#123; return value; &#125; public String description() &#123; return description; &#125; public static RechargeTypeEnum valueOf(int value) &#123; for(RechargeTypeEnum type : RechargeTypeEnum.values()) &#123; //传value的key,遍历枚举的所有value,得到大写字母整个枚举对象 if(type.value() == value) &#123; return type;//然后你可以输出type.description &#125; &#125; return null; &#125; public static void main(String[] args)&#123; RechargeTypeEnum aa = valueOf(4);//充值卡 System.out.println(aa.description); &#125;&#125; 策略接口：123456789101112131415161718public interface Strategy &#123;//策略接口 public Double calRecharge(Double charge ,RechargeTypeEnum type );&#125;class EBankStrategy implements Strategy&#123; public Double calRecharge(Double charge, RechargeTypeEnum type) &#123; return charge*0.85; &#125;&#125;//策略实现类class BusiAcctStrategy implements Strategy&#123; public Double calRecharge(Double charge, RechargeTypeEnum type) &#123; return charge*0.90; &#125;&#125; class MobileStrategy implements Strategy &#123; public Double calRecharge(Double charge, RechargeTypeEnum type) &#123; return charge+charge*0.01; &#125;&#125; 1234567891011121314public class Context &#123; private Strategy strategy; //策略上下文 public Double calRecharge(Double charge, Integer type) &#123; strategy = StrategyFactory.getInstance().creator(type); return strategy.calRecharge(charge, RechargeTypeEnum.valueOf(type)); &#125; public Strategy getStrategy() &#123; return strategy; &#125; public void setStrategy(Strategy strategy) &#123; this.strategy = strategy; &#125;&#125; 1234567891011121314151617public class StrategyFactory &#123; private static StrategyFactory factory = new StrategyFactory(); private StrategyFactory()&#123; &#125;//这里用了饿汉式（静态常量） +工厂模式 ，把数字作为key，value是策略的实现类 private static Map strategyMap = new HashMap&lt;&gt;(); static&#123;//key是数字，value是策略实现类 strategyMap.put(RechargeTypeEnum.E_BANK.value(), new EBankStrategy()); strategyMap.put(RechargeTypeEnum.BUSI_ACCOUNTS.value(), new BusiAcctStrategy()); strategyMap.put(RechargeTypeEnum.MOBILE.value(), new MobileStrategy()); &#125; public Strategy creator(Integer type)&#123; return (Strategy) strategyMap.get(type); &#125; public static StrategyFactory getInstance()&#123; return factory; &#125;&#125; 主方法：12345678910111213public class Client &#123; public static void main(String[] args) &#123; Context context = new Context(); // 网银充100 付多少 Double money = context.calRecharge(100D, RechargeTypeEnum.E_BANK.value()); System.out.println(money); // 商户充值100 付多少 Double money2 = context.calRecharge(100D, RechargeTypeEnum.BUSI_ACCOUNTS.value()); System.out.println(money2); 思路：声明环境类context，传入一个类型就是enum的key对应123和充值金额，工厂模式根据类型的数字，返回策略的实现类。因为静态工厂模式在类初始的时候，调用了静态代码块，把枚举的类型也就是123作为key，策略的实现作为value存到一个hashmap里。你传进去key就会返回一个对应的策略实现类。接着通过策略实现类和充值金额，再调用相对应的方法 calRecharge，就得到金额了还有一些重构比较好的例子，可以参考一下：点击这里 3.通过Aop记录请求参数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;环绕通知，必须手动执行目标方法.先声明切点入口的方法，通过环绕通知方法做请求参数和响应参数信息的记录，记录耗时的时长，如果出异常就调用异常通知处理。aspect类内部执行顺序：1经过@Around方法，再经过before，再到method方法，再回到@Around，再到@After方法，最后是异常通知1.target：目标类，需要被代理的类。例如：UserService2.Joinpoint(连接点):所谓连接点是指那些可能被拦截到的方法。例如：所有的方法3.PointCut 切入点：已经被增强的连接点。例如：addUser(),execution( com.itheima.c_spring_aop..*(..))4.advice 通知/增强，增强代码。例如：after、before123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148@Aspect@Componentpublic class WebControllerAop &#123; /** * 指定切点 * 匹配 net.sppan.base.controller包及其子包下的所有类的所有方法 */ @Pointcut(&quot;execution(* net.sppan.base.controller..*.*(..))&quot;) public void webLog() &#123; &#125; @Autowired ILogDao logDao; /** * 前置通知，方法调用前被调用 * * @param joinPoint */ @Before(&quot;webLog()&quot;) public void doBefore(JoinPoint joinPoint) &#123; // 获取HttpServletRequest ServletRequestAttributes srvletRequestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = srvletRequestAttributes.getRequest(); Map&lt;String, String[]&gt; map = request.getParameterMap(); // System.out.println(request.getParameterMap()+&quot;----&quot;); // System.out.println(Arrays.toString(joinPoint.getArgs())+&quot;----&quot;); Logs log=new Logs(); Subject sb = SecurityUtils.getSubject(); User user = (User) sb.getPrincipal(); if(user!=null)&#123; log.setUserId(user.getId()); log.setUserName(user.getUserName()); &#125;else&#123; log.setUserId(-1); log.setUserName(&quot;&quot;); &#125; System.out.println(&quot;我是前置通知!!!&quot;); //获取目标方法的参数信息 Object[] obj = joinPoint.getArgs(); Signature signature = joinPoint.getSignature(); Enumeration&lt;String&gt; num = request.getParameterNames(); StringBuffer str = new StringBuffer(); while(num.hasMoreElements())&#123; String paramName=(String)num.nextElement(); String[] values=request.getParameterValues(paramName); for(int i=0;i&lt;values.length;i++)&#123; str .append(paramName+&quot;=&quot;); str.append(values[i]+&quot;,&quot;); &#125; &#125; log.setParams(str.toString()); Map&lt;String, String&gt; heades = getHeadersInfo(request); for (Map.Entry&lt;String, String&gt; entry : heades.entrySet()) &#123; if(entry.getKey().equals(&quot;user-agent&quot;))&#123; log.setUserAgent(entry.getValue());//设置浏览器 &#125; &#125; //代理的是哪一个方法 // System.out.println(&quot;方法：&quot; + signature.getName()); log.setTitle(signature.getName()); log.setLastTime(new Date()); //AOP代理类的名字 // System.out.println(&quot;方法所在包:&quot; + signature.getDeclaringTypeName()); //AOP代理类的类（class）信息 signature.getDeclaringType(); MethodSignature methodSignature = (MethodSignature) signature; String[] strings = methodSignature.getParameterNames(); // log.setParams(request.getQueryString()); // 接收到请求，记录请求内容 ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest req = attributes.getRequest(); // 记录下请求内容 log.setRequestUri( req.getRequestURL().toString()); // System.out.println(&quot;HTTP_METHOD : &quot; + req.getMethod()); log.setMethod(req.getMethod()); boolean addlog=true; if(signature.getName().equals(&quot;initBinder&quot;)||signature.getName().equals(&quot;index&quot;)||signature.getName().equals(&quot;welcome&quot;))&#123; addlog=false; &#125; if(addlog) &#123; logDao.save(log); &#125; &#125; private Map&lt;String, String&gt; getHeadersInfo(HttpServletRequest request) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); Enumeration headerNames = request.getHeaderNames(); while (headerNames.hasMoreElements()) &#123; String key = (String) headerNames.nextElement(); String value = request.getHeader(key); map.put(key, value); &#125; return map; &#125; /** * 处理完请求返回内容 * @param ret * @throws Throwable */ @AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;webLog()&quot;) public void doAfterReturning(Object ret) throws Throwable &#123; // 处理完请求，返回内容 System.out.println(&quot;方法的返回值 : &quot; + ret); &#125; /** * 后置异常通知 * @param jp */ @AfterThrowing(pointcut = &quot;webLog()&quot;,throwing = &quot;e&quot;) public void throwss(JoinPoint jp,Exception e)&#123; if (!(e instanceof ServiceException)) &#123; System.out.println(&quot;捕获到了！！！！&quot;+e.getMessage()); &#125; System.out.println(&quot;方法异常时执行.....&quot;); &#125; /** * 后置最终通知,final增强，不管是抛出异常或者正常退出都会执行 * @param jp */ @After(&quot;webLog()&quot;) public void after(JoinPoint jp)&#123; &#125; /** * 环绕通知,环绕增强，相当于MethodInterceptor * @param pjp * @return */ @Around(&quot;webLog()&quot;) public Object arround(ProceedingJoinPoint pjp) &#123; try &#123; Object o = pjp.proceed(); return o; &#125; catch (Throwable e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 4.多线程导出poi思路： 就是你可以限制他的excel中的数据，通过查询时间来限制。默认导出1小时内的数据，然后管理员手动选择一天的话 ，就提示时间较长…那这 10 次查询也得开启10个线程查询吧 一个线程的的话时间也是一样长的，不要把所有的数据放在一个sheet中，分sheet存储,把你的查询数据也分页CountDownLatch是指合成所有的sheet为一个xlsx，在生成表格，就是等子线程完成所有任务，主线程才开始完成任务。数据在万条时XSSF和SXSSF相差不大，数据上十万后SXSSF性能开始突出，我这里测试了200万条数据，在加索引的情况下，这里暂时没对查询进行分页： 1234567891011List&lt;String&gt; fields=new ArrayList&lt;&gt;();fields.add(&quot;sc的id&quot;); fields.add(&quot;student的id&quot;);fields.add(&quot;course的id&quot;);fields.add(&quot;分数&quot;);long start = System.currentTimeMillis();List list = scService.findByScoreBetween(0,50);SXSSFWorkbook workbook =getSXSSFWorkbookByPageThread(fields, list );FileOutputStream outputStream = new FileOutputStream(&quot;F:\\out.xlsx&quot;);workbook.write(outputStream);outputStream.close(); 123456789101112131415161718192021222324252627282930public SXSSFWorkbook getSXSSFWorkbookByPageThread( List&lt;String&gt; fields, List list) &#123; LinkedHashMap&lt;String, List&gt; map = getDataStream(list); int sheetsize = map.size(); CountDownLatch downLatch = new CountDownLatch(sheetsize); ExecutorService executor = Executors.newFixedThreadPool(20); //这里的map是每个sheet名字对应的数据 Sheet sheet = null; SXSSFWorkbook workbook = null; CellStyle style = null; for (Map.Entry&lt;String, List&gt; entry : map.entrySet()) &#123; String sheetname = entry.getKey(); if (workbook == null) &#123; workbook = new SXSSFWorkbook(); &#125; List&lt;Sc&gt; poilist=entry.getValue(); style = workbook.createCellStyle(); style.setAlignment(XSSFCellStyle.ALIGN_CENTER); sheet = workbook.createSheet(sheetname); // 打开目的输入流，不存在则会创建 executor.execute(new PageTask(downLatch, sheet, fields, style, sheetsize, poilist )); &#125; try &#123; downLatch.await(); //关闭线程池 executor.shutdown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return workbook; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041class PageTask implements Runnable &#123; private CountDownLatch countDownLatch; private Sheet sheet; private List&lt;String&gt; title; private CellStyle style; private int rowNum; private List&lt;Sc&gt; poilist; public PageTask(CountDownLatch countDownLatch, Sheet sheet, List&lt;String&gt; title, CellStyle style, int rowNum, List&lt;Sc&gt; poilist) &#123; this.countDownLatch = countDownLatch; this.sheet = sheet; this.title = title; this.style = style; this.rowNum = rowNum; this.poilist = poilist; &#125; public void run() &#123; try &#123; Row row = sheet.createRow(0); Cell cell = null; for (int i = 0; i &lt; title.size(); i++) &#123; cell = row.createCell(i); cell.setCellValue(title.get(i)); cell.setCellStyle(style); &#125; for (int i = 0; i &lt; poilist.size(); i++) &#123; Row newrow = sheet.createRow(i + 1); newrow.createCell(0).setCellValue(poilist.get(i).getScId()); newrow.createCell(1).setCellValue(poilist.get(i).getSwId()); newrow.createCell(2).setCellValue(poilist.get(i).getCwId()); newrow.createCell(3).setCellValue(poilist.get(i).getScore()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (countDownLatch != null) &#123; countDownLatch.countDown(); &#125; &#125; &#125;&#125; 5.在多线程的情况下，读取数据库数据导出到excel文件的例子当中，每次处理一个时间信息的时候，就需要创建一个SimpleDateFormat实例对象，然后再丢弃这个对象。大量的对象就这样被创建出来，占用大量的内存和 jv,m空间,而且它不是线程安全的，比如转化的时间不正确，比如报错 calendar.setTime(date)这条语句改变了calendar，稍后，calendar还会用到（在subFormat方法里），而这就是引发问题的根源。想象一下，在一个多线程环境下，有两个线程持有了同一个SimpleDateFormat的实例，分别调用format方法： 线程1调用format方法，改变了calendar这个字段。 中断来了。 线程2开始执行，它也改变了calendar。 又中断了。 线程1回来了，此时，calendar已然不是它所设的值，而是走上了线程2设计的道路。如果多个线程同时争抢calendar对象，则会出现各种问题，时间不对，线程挂死等等。分析一下：其实，只要在这里用一个局部变量即可12345678910111213141516public class SimpleDateutils &#123; private static ThreadLocal&lt;DateFormat&gt; threadLocal=new ThreadLocal&lt;DateFormat&gt;()&#123; protected DateFormat initialValue()&#123; return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); &#125; &#125;; public static Date parse (String dateStr)throws ParseException&#123; return threadLocal.get().parse(dateStr); &#125; public static String format(Date date)&#123; return threadLocal.get().format(date); &#125;&#125; 说明：使用ThreadLocal, 也是将共享变量变为独享，线程独享肯定能比方法独享在并发环境中能减少不少创建对象的开销。 说下工作流注意的几个地方：1先把流程定义表部署进去，2启动流程定义，3，启动流程实例，把关联的业务主表id，登陆用户主要信息存到流程变量里。4.审核通过就把业务主表Id找到对应的实例id再找到任务id，执行就好了。5.如果是驳回的话，因为驳回他的业务busesskey还存在的，一样根据业务主表的id，找到任务id执行]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
